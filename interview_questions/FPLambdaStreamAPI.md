## FP Lambda Stream API

[1. Что такое lamdba выражение?](#1-Что-такое-lamdba-выражение)

[2. Что такое функциональные интерфейсы?](#2-Что-такое-функциональные-интерфейсы)

[3. Перечислите функциональные интерфейсы из пакета java.util.function?](#3-Перечислите-функциональные-интерфейсы-из-пакета-javautilfunction)

[4. Что такое функции высшего порядка?](#4-Что-такое-функции-высшего-порядка)

[5. Какие функциональные интерфейсы из пакета java.util.function поддерживают функции высшего порядка?](#5-Какие-функциональные-интерфейсы-из-пакета-javautilfunction-поддерживают-функции-высшего-порядка)

[6. Что такое ссылки на методы?](#6-Что-такое-ссылки-на-методы)

[7. Что такое ссылки на конструкторы?](#7-Что-такое-ссылки-на-конструкторы)

[8. Расскажите о зоне видимости переменных в lambda - выражениях?](#8-Расскажите-о-зоне-видимости-переменных-в-lambda-выражениях)

[9. Как быть в ситуации, если внутри lambda - выражении операторы могут выкинуть исключение?](#9-Как-быть-в-ситуации-если-внутри-lambda-выражении-операторы-могут-выкинуть-исключение)

[10. Что такое Stream API?](#10-Что-такое-Stream-API)

[11. Расскажите, какой шаблон проектирования используется внутри Stream API?](#11-Расскажите-какой-шаблон-проектирования-используется-внутри-Stream-API)

[12. Что делает метод filter?](#12-Что-делает-метод-filter)

[13. Что делает метод map.](#13-Что-делает-метод-map)

[14. Что делает метод flatMap?](#14-Что-делает-метод-flatMap)

[15. Что делает метод collect?](#15-Что-делает-метод-collect)

[16. Что делает метод reduce?](#16-Что-делает-метод-reduce)

[17. Что делает метод findFirst?](#17-Что-делает-метод-findFirst)

[18. Возможно ли прервать выполнение потока по аналогии с break?](#18-Возможно-ли-прервать-выполнение-потока-по-аналогии-с-break)

[19. Возможно ли пропустить элемент потока по аналогии с continue?](#19-Возможно-ли-пропустить-элемент-потока-по-аналогии-с-continue)

[20. Что такое Optional?](#20-Что-такое-Optional)

[21. Перечислите методы Optional?](#21-Перечислите-методы-Optional)

[22. Расскажите про фабричные методы List.of, Set.of, Map.of?](#22-Расскажите-про-фабричные-методы-Listof-Setof-Mapof)

[23. Для чего используется ключевое слово var?](#23-Для-чего-используется-ключевое-слово-var)

[24. В каких случаях можно использовать var?](#24-В-каких-случаях-можно-использовать-var)

[25. ](#25-)

## 1. Что такое lamdba выражение?

Лямбда-выражение представляет собой блок кода, который можно передать в другое место. Этот блок кода может быть выполнен 
позже один или несколько раз. Т.е. для Лямбда-выражения характерно отложенное выполнение.
По существу lambda это анонимным (безымянным) методом, который реализует определенный в функциональном интерфейсе.
```java
(входящие параметры через запятую без указания типа) -> {
    операторы;
    return вычисленное значение;
}
```
Основу лямбда-выражения составляет лямбда-оператор, который представляет стрелку **->**. Этот оператор разделяет лямбда-выражение на две части: левая часть содержит список параметров выражения, а правая собственно представляет тело лямбда-выражения, где выполняются все действия.

Если функция не принимает параметры, то указываем пустые скобки. Если функция прнимает один параметр, то скобки можем упустить. Если выражение содержит единственный оператор return или вообще не содержит, то его можно убрать вместе с фигурными скобками.
```java
Comparator<Attachment> comparator = (left, right) -> Integer.compare(left.getSize(), right.getSize());
```
Лямда-выражения могут быть не терминальными (возвращать значения) и терминальными (значение не возвращается).

[к оглавлению](#FP-Lambda-Stream-API)

## 2. Что такое функциональные интерфейсы?

Функциональным называется интерфейс, который содержит только один абстрактный метод. Абстрактный метод - это метод в котором нет реализации.

Основное назначение – использование в лямбда выражениях, в ссылках на методы или в ссылках на конструкторы.
Функциональный интерфейс может содержать так же `default` и `static` методы.
К функциональному интерфейсу можно добавить аннотацию `@FunctionalInterface`

[к оглавлению](#FP-Lambda-Stream-API)

## 3. Перечислите функциональные интерфейсы из пакета javautilfunction?

В JDK в пакете java.util.function встроены готовые функциональные интерфейсы, описывающие всевозможные варианты.
Это `Consumer<T>`, `Function<T,R>`, `Predicate<T>`, `Supplier<T>`, `UnaryOperator<T>`, `BinaryOperator<T>` и их `Bi` – формы

+ **Predicate<T>** (утверждение) - проверяет соблюдение некоторого условия.
Если оно соблюдается, то возвращается значение `true`. В качестве параметра лямбда-выражение принимает объект типа `T`. Наиболее часто применяется в фильтрах и сравнении.

+ **Function<T,R>** - представляет функцию перехода от объекта типа `T` к объекту типа `R`.

+ **Consumer<T>** (потребитель) - выполняет некоторое действие над объектом типа `T`, при этом ничего не возвращая.

+ **Supplier<T>** (поставщик) - принимает никаких аргументов, но должен возвращать объект типа `T`.

+ **BinaryOperator<T>** - принимает в качестве параметра два объекта типа `T`, выполняет над ними бинарную операцию
и возвращает ее результат также в виде объекта типа `T`.

+ **UnaryOperator<T>** - принимает в качестве параметра объект типа `T`,
выполняет над ними операции и возвращает результат операций в виде объекта типа `T`.

![Функциональные интерфейсы](https://github.com/greenman777/job4j/blob/master/interview_questions/Function%20Interface.jpg)
  
подробнее https://metanit.com/java/tutorial/9.3.php

[к оглавлению](#FP-Lambda-Stream-API)

## 4. Что такое функции высшего порядка?

Функции высшего порядка принимают другие функции в качестве своих параметров или возвращают 
другие функции в качестве своих результатов.

У языка Java появились функции высшего порядка в форме так называемых лямбда-выражений.

Основная идея: функции имеют тот же статус, что и другие объекты данных.
    
```java
Function<Integer,Integer>   f = x -> x + 3;
BiFunction<Function<Integer,Integer>, Integer, Integer> g = (func, x) -> func.apply(x) * func.apply(x);
System.out.println(g.apply(f,7));
```

[к оглавлению](#FP-Lambda-Stream-API)

## 5. Какие функциональные интерфейсы из пакета javautilfunction поддерживают функции высшего порядка?
Функциональные интерфейсы поддерживают функции высшего порядка, потому что могут принимать их в качестве аргумента или возвращать.

[к оглавлению](#FP-Lambda-Stream-API)

## 6. Что такое ссылки на методы?

Начиная с JDK 8 в Java можно в качестве параметра в метод передавать ссылку на другой метод.
В принципе данный способ аналогичен передаче в метод лямбда-выражения.

Ссылка на метод - это компактное лямбда-выражение, которое позволяет передавать ссылки на методы или конструкторы.

Ссылка на метод передается в виде:
+ `имя_класса::имя_статического_метода` ссылка на статический метод.

для нестатических методов:
+ `объект_класса::имя_метода` на метода конкретного объекта (экземпляра).
+ `тип_объекта::имя_метода` на метод произвольного объекта конкретного типа.
+ `название_класса::new` ссылка на конструктор.

И если лямда-выражение вызывает только один метод, вы можете использовать **ссылку на метод** - `method reference` для непосредственной передачи этого метода.
```java
Consumer<String> consumer = (name) -> System.out.println(name);

Consumer<String> consumer = System.out::println;  
    
Arrays.sort(strs, String::compareToIgnoreCase)
    
this::equals
```
    
    
[к оглавлению](#FP-Lambda-Stream-API)

## 7. Что такое ссылки на конструкторы?
Ссылки на конструктор такие же, как ссылки на метод, за исключением того, что именем метода является new.
Можно в качестве параметров использовать конструкторы: `название_класса::new`, для дженериков `название_класса<T>::new`.

При использовании конструкторов методы функциональных интерфейсов должны принимать тот же список параметров,
что и конструкторы класса, и должны возвращать объект данного класса.
```java
List<String> strs = ...;
Stream<Button> stream = strs.stream().map(Button::new);
List<Button> buttons = stream.collect(Collectors.toList());
```
Какой именно конструктор будет вызван, зависит от контекста. В частности, если конструктор вызывается в реализации функционального интерфейса, конструктор определяется параметрами функционального метода.
    
[к оглавлению](#FP-Lambda-Stream-API)

## 8. Расскажите о зоне видимости переменных в lambda выражениях?
    
**Есть несколько правил:**
+ Переменная, объявленная внутри лямбда-выражения, доступна только в самом лямбда-выражении.
+ Переменная, объявленная вне лямбда-выражения, доступна как внутри лямбда-выражения, так и вне его.
+ Переменную, объявленную вне лямбда-выражения, изменять внутри лямбда-выражения нельзя.

Лямбда-выражения имеют доступ к переменным в области видимости, в которой их определили.
Но в лямбда-выражении можно ссылаться только на переменные, значения которых не меняются. Т.е. доступ возможен только при условии, что переменные являются `effective final`, то есть либо переменные явно имеют модификатор `final`, либо не меняют своего значения после инициализации.
Если переменной присваивается значение во 2й раз, то лямбда-выражение вызовет ошибку компиляции.

Можно ссылаться на:
+ `effective final` локальные переменные (читать);
+ поля классов (читать и изменять);
+ статические переменные классов (читать и изменять).

Существует причина для этого ограничения. Изменяющиеся переменные в лямбда-выражениях не потокобезопасны.   
    
[к оглавлению](#FP-Lambda-Stream-API)

## 9. Как быть в ситуации, если внутри lambda выражении операторы могут выкинуть исключение?

Лямбда-выражение может генерировать исключение.
В общем случае в лямбда-выражениях нельзя использовать методы, которые могут выбросить исключения.
Поток данных не должен прерываться. Поэтому лучше всего не использовать лямбда-выражения с исключениями.
    
+ если тело лямбда-выражения может бросить проверяемое `checked` исключение, то оно должно быть объявлено в 
абстрактном методе целевого функционального интерфейса в выражении `throws`.
+ либо должно быть обработано внутри лямбда-выражения с помощью конструкции `try-catch-finally` (это лишает лямбда выражения своей краткости).
+ существует подход, когда сначала мы пишем метод-обертку, который будет отвечать за обработку исключения, а затем передаём лямбда-выражение в качестве параметра этому методу.

```java
static Consumer lambdaWrapper(Consumer consumer) {
    return i -> {
        try {
            consumer.accept(i);
        } catch (ArithmeticException e) {
            System.err.println(
              "Arithmetic Exception occured : " + e.getMessage());
        }
    };
}

List integers = Arrays.asList(3, 9, 7, 0, 10, 20);
integers.forEach(lambdaWrapper(i -> System.out.println(50 / i)));    
 ```
    
Как известно из функциональных интерфейсов в `Stream API` нельзя выбрасывать контролируемые исключения.
Если по каким-то причинам это необходимо (например, работа с файлами, базами данных или по сети),
приходится оборачивать их в `RuntimeException`. Сделать это можно с помощью конструкции `try-catch-finally` или с помощью метода обертки.

```java
@FunctionalInterface
public interface ThrowingConsumer {
    void accept(T t) throws E;
}
    
static  Consumer throwingConsumerWrapper(
  ThrowingConsumer throwingConsumer) {

    return i -> {
        try {
            throwingConsumer.accept(i);
        } catch (Exception ex) {
            throw new RuntimeException(ex);
        }
    };
}

List integers = Arrays.asList(3, 9, 7, 0, 10, 20);
integers.forEach(throwingConsumerWrapper(i -> writeToFile(i)));
```

подробней https://www.codeflow.site/ru/article/java-lambda-exceptions

[к оглавлению](#FP-Lambda-Stream-API)

## 10. Что такое Stream API?

Начиная с JDK 8 в Java появился новый API - Stream API. Его задача - упростить работу с наборами данных, в частности, 
упростить операции фильтрации, сортировки и другие манипуляции с данными. 

Вся основная функциональность данного API сосредоточена в пакете `java.util.stream`. 
Ключевым понятием в Stream API является поток данных. 
Поток представляет канал передачи данных из источника данных.
Причем в качестве источника могут выступать как файлы, так и массивы и коллекции.

Все операции над потоками бывают 2х видов:
+ `terminal` терминальные или конечные операции возвращают конкретный результат (`void` или результат определенного типа).
+ `intermediate` промежуточные или конвейерные операции возвращают трансформированный поток.


Все потоки производят вычисления, в т.ч. в промежуточных операциях, только когда к ним применяется терминальная операция.
Т.е. в данном случае применяется отложенное выполнение.

Потоки не могут быть использованы повторно - как только была вызвана конечная операция, поток закрывается.

Одной из отличительных черт Stream API является применение лямбда-выражений, которые позволяют значительно
сократить запись выполняемых действий. Т.е. Stream API позволяет взаимодействовать с данными в функциональном стиле, 
пердставляя их в качестве конечного потока данных.

![Stream](https://github.com/greenman777/job4j/blob/master/interview_questions/stream.png)
 
Javadoc https://docs.oracle.com/javase/8/docs/api/java/util/stream/Stream.html

Полное руководство по Java 8 Stream API в картинках и примерах https://annimon.com/article/2778

Шпаргалка Java программиста 4. Java Stream API https://habr.com/ru/company/luxoft/blog/270383/

[к оглавлению](#FP-Lambda-Stream-API)

## 11. Расскажите какой шаблон проектирования используется внутри Stream API?

Для построения потоков при работе со Stream используется шаблон проектирования Builder (в переводе на русский - Строитель). 

Строитель - это порождающий шаблон проектирования, который позволяет создавать сложные объекты пошагово. Строитель позволяет использовать один и тот же код построения объекта для получения разных представлений объектов.

Шаблон предлагает разбить процесс конструирования объекта на отдельные шаги. Чтобы создавать объекты таким образом, нам нужно поочередно вызывать методы строителя. При этом нам не нужно запускать все шаги, а только те, которые нужны для производства объекта определенной конфигурации. Методы возвращают один и тот же тип Builder. 
Метод build() вызывается для того, чтобы вернуть готовый объект. Его поведение схоже с терминальными операциями в Stream API.

```java
static class Builder {
    private String name;
    private String surname;
}

Builder buildName(String name) {
    this.name = name;
    return this;
}

Builder buildSurname(String surname) {
    this.surname = surname;
    return this;
}

User build() {
    User user = new User();
    user.name = name;
    user.surname = surname;
    return user;
}

public static void main(String[] args) {
    User user = new Builder().buildName("name")
            .buildSurname("surname")
            .build();
    System.out.println(user);
}
```

Когда стоит использовать шаблон проектирования Builder (Строитель):

+ Когда мы хотим избавиться от конструктора с большим количеством параметров (случай описанный в задании);

+ Когда код должен создавать разные представления какого-то объекта. Например, когда нам надо инициализировать лишь несколько полей из всего набора;

+ Когда нам необходимо собирать сложные объекты, т.е. когда поля в классе являются экземплярами других классов.

**Преимущества** использования шаблона Строитель:

+ Позволяет создавать объекты пошагово;

+ Позволяет использовать один и тот же код для создания различных объектов - если использовать не класс Builder, а interface с таким именем, тогда можно создавать различные имплементации этого интерфейса (в данном задании мы это не рассматривали);

+ Сложный код сборки объекта от основной бизнес логики будет изолирован.

**Недостатки** использования шаблона Строитель:

+ Усложняет код программы из-за введения дополнительных классов.

 ***Кроме того при разработке stream api использовался шаблон проектирования*** ```Pipeline```
 
    Для выполнения вычислений потоковые операции составляются в потоковый конвейер. 
Потоковый конвейер состоит из источника (который может быть массивом, коллекцией, функцией генератора, каналом ввода-вывода и т.д.), 
нуля или более промежуточных операций (которые преобразуют поток в другой поток, например `filter(Predicate)`), 
и терминальной операции (которая производит результат или побочный эффект, такой как `count()` или `forEach(Consumer)`). 
Потоки ленивы - вычисление исходных данных выполняется только тогда, когда инициируется работа терминала, а исходные 
элементы потребляются только по мере необходимости.

[к оглавлению](#FP-Lambda-Stream-API)

## 12. Что делает метод filter?

`filter` промежуточная операция, используется для фильтрации через функцию.

Он принимает в качестве параметра некоторое условие в виде объекта `Predicate<T>`
и возвращает новый поток из элементов, которые удовлетворяют этому условию.

```java
List lines = Arrays.asList("spring", "node", "alien");

List result = lines.stream()              
.filter(line -> !"alien".equals(line))
.collect(Collectors.toList());
```
    
[к оглавлению](#FP-Lambda-Stream-API)

## 13. Что делает метод map?

`map` промежуточная операция. Отображение или маппинг позволяет задать функцию преобразования одного объекта в другой,
то есть получить из элемента одного типа элемент другого типа.

`<R> Stream<R> map(Function<? super T, ? extends R> mapper) `
Передаваемая в метод `map` функция задает преобразование от объектов типа `T` к типу `R`.
И в результате возвращается новый поток с преобразованными объектами.

Map применяет функцию к каждому элементу и затем возвращает стрим, в котором элементами будут результаты функции. 
Так же map можно применять для изменения типа элементов.
```
Stream.mapToDouble(ToDoubleFunction mapper)
Stream.mapToInt(ToIntFunction mapper)
Stream.mapToLong(ToLongFunction mapper)
```
```java
Stream.of("10", "11", "12")
    .map(x -> Integer.parseInt(x))
    .forEach(System.out::println);
```
[к оглавлению](#FP-Lambda-Stream-API)

## 14. Что делает метод flatMap?

`flatMap` промежуточная операция. Плоское отображение похоже на `map`, но может создавать из одного элемента несколько. 
Т.е. каждый объект будет преобразован в 0, 1 или несколько других объектов, поддерживаемых потоком. 

`<R> Stream<R> flatMap(Function<? super T, ? extends Stream<? extends R>> mapper)`

Например мы хотим вывести на экран список всех домашних животных, которые есть у людей.

```java
class Human {
    private final String name;
    private final List<String> pets;
 
    //constructors, getters
}

public static void main(String[] args) {
    List<Human> humans = asList(
            new Human("Sam", asList("Buddy", "Lucy")),
            new Human("Bob", asList("Frankie", "Rosie")),
            new Human("Marta", asList("Simba", "Tilly")));
 
    List<String> petNames = humans.stream()
            .flatMap(human -> human.getPets().stream())
            .collect(Collectors.toList());
 
    System.out.println(petNames); // output [Buddy, Lucy, Frankie, Rosie, Simba, Tilly]
}
```

[к оглавлению](#FP-Lambda-Stream-API)

## 15. Что делает метод collect?

`collect` терминальная операция, преобразует поток в коллекцию. 

Мы можем написать свою реализацию функции, однако Java уже предоставляет ряд встроенных функций, 
определенных в классе `Collectors`:
+ `toList()` преобразование к типу `List`
+ `toSet()` преобразование к типу `Set`
+ `toMap()` преобразование к типу `Map`

```java
List<String> filteredPhones = phones.stream()
                .filter(s->s.length()<10)
                .collect(Collectors.toList());

Map<String, Integer> phones = phoneStream
            .collect(Collectors.toMap(p->p.getName(), t->t.getPrice()));
```
Если нам надо создать какой-то определенный тип коллекции, например, HashSet, то мы можем использовать специальные функции, которые определены в классах-коллекций. Например, получим объект HashSet:

```java
HashSet<String> filteredPhones = phones.filter(s->s.length()<12).
                                    collect(Collectors.toCollection(HashSet::new));
```
Выражение HashSet::new представляет функцию создания коллекции.

Вторая форма метода collect имеет три параметра:
```java
<R> R collect(Supplier<R> supplier, BiConsumer<R,? super T> accumulator, BiConsumer<R,R> combiner)
```
+ supplier: создает объект коллекции. Возвращает функцию, которая создает экземпляр изменяемой структуры данных, которую мы будем использовать для накопления элементов ввода типа  T.

+ accumulator: добавляет элемент в коллекцию. Возвращает функцию, которая возьмет аккумулятор и один элемент типа  T, мутирующий аккумулятор.

+ combiner: бинарная функция, которая объединяет два объекта. Используется для объединения двух аккумуляторов в один. Он используется, когда сборщик выполняется параллельно, Stream<T> сначала разделяя входные данные  и собирая их независимо.

```java
ArrayList<String> filteredPhones = phones.filter(s->s.length()<12)
            .collect(
                ()->new ArrayList<String>(), // создаем ArrayList
                (list, item)->list.add(item), // добавляем в список элемент
                (list1, list2)-> list1.addAll(list2)); // добавляем в список другой список
```

**Чтобы сгруппировать данные по какому-нибудь признаку, нам надо использовать в связке метод** ```collect()``` объекта ```Stream``` и метод ```Collectors.groupingBy().```

```java
Map<String, Long> map3 = workers.stream()
       .collect(Collectors.groupingBy(Worker::getPosition, Collectors.counting()));
```

**Метод** ``` Collectors.partitioningBy() ``` **имеет похожее действие, только он делит элементы на группы по принципу, соответствует ли элемент определенному условию. Например:**

```java
Map<Boolean, List<Phone>> phonesByCompany = phoneStream.collect(
                Collectors.partitioningBy(p->p.getCompany()=="Apple"));
```

+ Метод ``` Collectors.counting ``` применяется в Collectors.groupingBy() для вычисления количества элементов в каждой группе:

+ Метод ``` Collectors.summing ``` применяется для подсчета суммы. В зависимости от типа данных, к которым применяется метод, он имеет следующие формы: summingInt(), summingLong(), summingDouble(). 

+ Методы ``` maxBy ``` и ``` minBy ``` применяются для подсчета минимального и максимального значения в каждой группе. В качестве параметра эти методы принимают функцию компаратора, которая нужна для сравнения значений. Например, найдем для каждой компании телефон с минимальной ценой

+ Методы ``` summarizingInt() ``` / ``` summarizingLong() ``` / ``` summarizingDouble() ``` позволяют объединить в набор значения соответствующих типов

[к оглавлению](#FP-Lambda-Stream-API)

## 16. Что делает метод reduce?

`reduce` позволяет выполнять агрегатные функции на всей коллекцией и возвращать один результат.
Т.е. позволяет преобразовать все элементы стрима в один объект. Например, посчитать сумму всех элементов.
```java
    int sum = Stream.of(1,2,3,4,5).
        reduce(10, (acc, x) -> acc + x)); //10+1+2+3+4+5=25
```

Метод `reduce` выполняет терминальные операции сведения, возвращая некоторое значение - результат операции.
Он имеет следующие формы:
1. `Optional<T> reduce(BinaryOperator<T> accumulator)`
2. `T reduce(T identity, BinaryOperator<T> accumulator)`
3. `U reduce(U identity, BiFunction<U,? super T,U> accumulator, BinaryOperator<U> combiner)`

**Первая форма** возвращает результат в виде объекта `Optional<T>`. Например, вычислим произведение набора чисел:

```java
    Stream<Integer> numbersStream = Stream.of(1,2,3,4,5,6);
    Optional<Integer> result = numbersStream.reduce((x,y)->x*y);
    System.out.println(result.get()); // 720
```

Объект `BinaryOperator<T>` представляет функцию, которая принимает два элемента и выполняет над ними некоторую операцию,
возвращая результат. При этом метод reduce сохраняет результат и затем опять же применяет к этому результату
и следующему элементу в наборе бинарную операцию.

Если нам надо, чтобы первым элементом в наборе было какое-то определенное значение, то мы можем использовать **вторую
версию** метода `reduce()`, которая в качестве первого параметра принимает `T identity`.
Этот параметр хранит значение, с которого будет начинаться цепочка бинарных операций. Например:

```java
    Stream<String> wordsStream = Stream.of("мама", "мыла", "раму");
    String sentence = wordsStream.reduce("Результат:", (x,y)->x + " " + y);
    System.out.println(sentence); // Результат: мама мыла раму
```
**Третья форма записи reduce**

```java
<U> U reduce(U identity,
             BiFunction<U, ? super T, U> accumulator,
             BinaryOperator<U> combiner);
```

**accumulator** - это функция, которая добавляет элемент Stream (тип которого обозначен T) к промежуточному результату операции reduce (тип которой обозначен U) и возвращает обновленный результат (также типа U).

**combiner** берет два промежуточных результата (оба одного типа U) и объединяет их в результат, тип которого также U.

Допустим мы хотим найти сумму цен тех телефонов, у которых цена меньше определенного значения.
Для этого используем третью версию метода `reduce`:

```java
    Stream<Phone> phoneStream = Stream.of(new Phone("iPhone 6 S", 54000),
                new Phone("Lumia 950", 45000),
                new Phone("Samsung Galaxy S 6", 40000),
                new Phone("LG G 4", 32000));
    int sum = phoneStream.reduce(0,
                (x,y)-> {
                        if(y.getPrice()<50000)
                            return x + y.getPrice();
                        else
                            return x + 0;
                },
                (x, y)->x+y);
    System.out.println(sum); // 117000
```

[к оглавлению](#FP-Lambda-Stream-API)

## 17. Что делает метод findFirst?

`findFirst` терминальная операция, возвращает первый элемент из стрима в виде обертки `Optional`

[к оглавлению](#FP-Lambda-Stream-API)

## 18. Возможно ли прервать выполнение потока по аналогии с break?

Stream может выполнятся в несколько параллельных потоков, поэтому прерывание может привести к некорректным результатам.

С Java 9 можно использовать `java takeWhile` - промежуточная операция, возвращает элементы до тех пор, пока они
удовлетворяют условию, т.е. предикат возвращает `true`.

Пример:

```java
list.stream().takeWhile(item -> !item.isEmpty()) .forEach(item -> processItem(item));
```

[к оглавлению](#FP-Lambda-Stream-API)

## 19. Возможно ли пропустить элемент потока по аналогии с continue?

Вместо этого можно использовать `filter` - промежуточная операция, фильтрует элементы по условию.

```java
list.stream() .filter(item -> !item.isEmpty()) .forEach(item -> processItem(item));
```

А также `return`:

```java
    public static void main(String[] args) {
        ArrayList<String> stringList = new ArrayList<>();
        stringList.add("a");
        stringList.add("b");
        stringList.add("c");
        stringList.stream().forEach(str -> {
            if (str.equals("b")) return; // only skips this iteration.
            System.out.println(str); // a c
        });
    }
```

[к оглавлению](#FP-Lambda-Stream-API)

## 20. Что такое Optional?

В релизе Java 8 появился новый класс `Optional` призванный помочь разработчикам в обработке `NullPointerException`.

Опциональное значение `Optional` - это контейнер для объекта. Он может содержать значение или некоторый тип `<T>`, или
просто быть `null`.

Такая обертка является удобным средством предотвращения `NullPointerException`, т.к. имеет некоторые функции высшего 
порядка, избавляющие от добавления повторяющихся `if null/not null` проверок, что позволяет фокусироватья на 
выполнении непосредственной задачи.

```java
    //Пустой Optional объект
    Optional<Person> optionalPerson = Optional.empty();
    
    //Optional объект с ненулевым значением
    Optional<Person> optionalNonNull = Optional.of(somePerson);
    
    //Optional объект с возможностью нулевого значения
    Optional<Person> optionalNullable = Optional.ofNullable(somePerson);
```

Метод `ifPresent()` позволяет также устранить некоторую избыточность кода, следующего вида:
```java
     if(person != null) {
    	System.out.println(person);
     }
```
Те же действия, но с использованием `Optional`: `person.ifPresent(System.out::println);`

`orElse()`, `orElseThrow()`:

Как было раньше:`java Person personNew = person != null ? person : new Person();`

То же самое, но с использованием `Optional`: `Person personNew = person.orElse(new Person());`

Или, если не хотим создавать объект, можно выбросить исключение:
`java Person personNewThrow = person.orElseThrow(Exception::new);`

[к оглавлению](#FP-Lambda-Stream-API)

## 21. Перечислите методы Optional?

+ `Optional.empty()` - возвращает `Optional` с `null` внутри.
+ `Optional.of(T value)` - возвращает `Optional` с `not null` значением внутри.
+ `Optional.ofNullable(T value)` - возвращает `Optional` который может содержать `null` значение внутри.

Методы конкретного объекта `Optional`:
+ `filter(Predicate<? super T> predicate)` - дает возможность отфильтровать значение опционального типа.
Мы передаем ему в параметр `Predicat` (это стандартный функциональный интерфейс), он возвращает булево значение. 
Если значение `true`, то возвращается этот же опционал, 
если значение `false`, то возвращается пустой опционал `Optional.empty()`.

+ `flatMap(Function<? super T,Optional<U>> mapper)` - применяется для изменения значения установленного в опционале. 
Функция которая передается в метод `flatMap` должна возвращать опционал. 
Если значение не установлено, вернется `Optional.empty()`.

+ `get()` - возвращает значение из объекта `Optional`. Нужно аккуратно использовать этот метод, т.к. он может бросить 
исключение `NoSuchElementException`, если значение в опционале равно `null`.
Чтобы безопасно использовать этот метод, перед его вызовом надо вызвать метод `isPresent()`.

+ `isPresent()` - возвращает булево значение `true`, если в опционале значение есть и возвращает `false`,
 если в опционале значение `null`.

+ `orElse(T other)` - используется для того, чтобы установить значение по-умолчанию в том случае,
если значение в опционале отсутствует.

+ `orElseGet(Supplier<? extends T> other)` - это аналог метода `orElse`,
только принимает в себя функциональный интерфейс, который должен вернуть значение.

+ `orElseThrow(Supplier<? extends X> exceptionSupplier)` - используется для того, чтобы бросить исключение,
которое передается в метод `orElseThrow`, если значения в опционале не установлено.

+ `ifPresent(Consumer<? super T> consumer)` - исполняет функциональный интерфейс `Consumer`, если значение в опционале 
присутствует. Т.е. в `ifPresent` передается фуекция, которая принимает один параметр - значение из `Optional`.

подробнее https://habr.com/ru/post/346782/

[к оглавлению](#FP-Lambda-Stream-API)

## 22. Расскажите про фабричные методы Listof Setof Mapof?

С приходом Java 9 создавать неизменяемые `immutable` коллекции `List`, `Set`, `Map` стало намного проще.
Фабричные методы позволяют преобразовывать элементы в потоки.

1. Создание списка `List<Integer> nums = List.of(1,2,3,4,5);`

    Метод `of()` в интерфейсе `List` перегружен и принимает от одного до десяти элементов. 
Если хотим создать коллекцию с более чем десятью элементами, тогда будет использоваться перегруженный метод с `varargs`:
`static <E> List<E> of(E... elements)`. Это сделано с целью оптимизации, т.к. при каждом вызове метода c `varargs` 
будет создаваться новый массив

2. Создание множества `Set<String> questions = Set.of("What?", "Where?", "When?");`

    Метод `of()` также имеет перегруженные методы, но в отличии от `List`, если передать дубликат в метод `of()`, то получим исключение
`Set<String> questions = Set.of("What?", "What?"); // IllegalArgumentException: duplicate element: What?`

3. Создание карты `Map<String, String> params = Map.of("Name:", "John", "Surname:", "Snow", "Status:", "Unmarried");`

    Последовательности идут парами `key`, `value`. Всего таких пар может быть 10, в отличии от `List` и `Set`,
если в последовательности будут повторения ключей - получим исключение
`Map.of("уникально", "наверняка", "уникально", "но это не точно"); // IllegalArgumentException: duplicate key: уникально`

Обратите внимание:
+ Вышеупомянутые коллекции нельзя изменить, при попытке получим `UnsupportedOperationException`.
+ В метод `of()` нельзя передать `null`, во всех коллекциях получим `NullPointerException`.
+ Метод `of()` не создает привычные `ArrayList`, `HashSet` или `HashMap`. В Java 9 были созданы специальные 
`ImmutableCollections` которые и возвращаются.
+ `ImmutableCollections` являются сериализуемыми, если содержимое тоже является сериализуемым.

[к оглавлению](#FP-Lambda-Stream-API)

## 23. Для чего используется ключевое слово var?

Нововведение Java 10 `var` аббревеатура `Local Variable Type-Inference`, 
используется для вывода типов локальных переменных.

Дает возможность сократить объявления переменных используя ключевое слово `var`.
При обработке `var`, компилятор просматривает правую часть объявления,
так называемый инициализатор и использует его тип для переменной.

`var` доступна только для локальных переменных с инициализатором. 
```java
     var first = 1;
     var second = 2;
     var rst = first + second;
     System.out.println(rst);
     
     var list = List.of(1, 2, 5);
     
     for(var item : items) {
        System.out.println(item);
     }
```

`var` это зарезервированное имя, но не ключевое слово (наряду с `true`, `false`, и `null`), что обеспечивает обратную 
совестимость программ, использующих его.

`var` нельзя использовать для:
+ полей класса;
+ параметров методов;
+ переменных без знания (т.е. без инициализатора).

также `var`:
+ не будет работать, если инициализируется `null`.
+ не будет работать для нелокальных переменных.
+ нельзя использовать в лямбда-выражениях, т.к. им нужен явный целевой тип.
+ нельзя использовать в случае инициализации массива.

[к оглавлению](#FP-Lambda-Stream-API)

## 24. В каких случаях можно использовать var?

`var` может использоваться только в сочетании с данными, т.е. нужно обязательно инициализировать переменную.
Компилятору нужно знать тип переменной, а тип можно извлечь только из значения.

[к оглавлению](#FP-Lambda-Stream-API)

## 25. ?



[к оглавлению](#FP-Lambda-Stream-API)

## Источники:

Изменения в языке Java 8 
https://www.ibm.com/developerworks/ru/library/j-java8lambdas/index.html

Встроенные функциональные интерфейсы
https://metanit.com/java/tutorial/9.3.php

Исключения в лямбда-выражениях Java 8
https://www.codeflow.site/ru/article/java-lambda-exceptions

Javadoc `Interface Stream<T>` 
https://docs.oracle.com/javase/8/docs/api/java/util/stream/Stream.html

Полное руководство по Java 8 Stream API в картинках и примерах 
https://annimon.com/article/2778

Шпаргалка Java программиста 4. Java Stream API 
https://habr.com/ru/company/luxoft/blog/270383/

паттерне pipeline 
https://medium.com/@deepakbapat/the-pipeline-design-pattern-in-java-831d9ce2fe21

Optional: Кот Шрёдингера в Java 8
https://habr.com/ru/post/346782/
