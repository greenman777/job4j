## Collections Pro

#### part 1. [Collections Lite](CollectionsLite.md#collections-lite)

[1. Что такое генерики?](#1-Что-такое-генерики)

[2. Что такое wild cards?](#2-Что-такое-wild-cards)

[3. Где хранится информация про Generics?](#3-Где-хранится-информация-про-Generics)

[4. Как можно получить тип Generics?](#4-Как-можно-получить-тип-Generics)

[5. Что такое итератор?](#5-Что-такое-итератор)

[6. Что такое коллекции?](#6-Что-такое-коллекции)

[7. Назовите базовые интерфейсы коллекций?](#7-Назовите-базовые-интерфейсы-коллекций)

[8. Расскажите реализации интерфейса List?](#8-Расскажите-реализации-интерфейса-List)

[9. Расскажите реализации интерфейса Set?](#9-Расскажите-реализации-интерфейса-Set)

[10. Расскажите реализации интерфейса Map?](#10-Расскажите-реализации-интерфейса-Map)

[11. Отличие ArrayList от LinkedList?](#11-Отличие-ArrayList-от-LinkedList)

[12. Отличие Set от List?](#12-Отличие-Set-от-List)

[13. Расскажите про методы Object hashCode и equals?](#13-Расскажите-про-методы-Object-hashCode-и-equals)

[14. Расскажите, что такое коллизии в Map? Как с ними бороться?](#14-Расскажите-что-такое-коллизии-в-Map-Как-с-ними-бороться)

[15. Расскажите, что такое анализ алгоритма?](#15-Расскажите,-что-такое-анализ-алгоритма)

[16. Какая временная сложность алгоритмов(O-нотация) добавления, замены и удаления в каждой из коллекций? С чем связаны отличия?](#16-Какая-временная-сложность-алгоритмов-добавления,-замены-и-удаления-в-каждой-из-коллекций-С-чем-связаны-отличия)

[17. Расскажите реализации данных очередей и стеков?](#17-Расскажите-реализации-данных-очередей-и-стеков)

[18. Расскажите про реализации деревьев?](#18-Расскажите-про-реализации-деревьев)

[19. Что такое loadFactor?](#19-Что-такое-loadFactor)

[20. Пример какова сложность поиска значения по ключу?](#20-Пример-какова-сложность-поиска-значения-по-ключу)

[21. Расскажите правило для переопределения метода hashCode?](#21-Расскажите-правило-для-переопределения-метода-hashCode)

[22. Приведите пример переопределения hashCode?](#22-Приведите-пример-переопределения-hashCode)

[23. Как вычисляется hash функция от объекта в HashMap?](#23-Как-вычисляется-hash-функция-от-объекта-в-HashMap)

[24. Правила проверки при переопределении метода equals?](#24-Правила-проверки-при-переопределении-метода-equals)

[25. Как устроена HashMap?](#25-Как-устроена-HashMap?)

[26. Какое начальное количество корзин в HashMap?](#26-Какое-начальное-количество-корзин-в-HashMap)

[27. Какая оценка временной сложности выборки элемента из HashMap? Гарантирует ли HashMap указанную сложность выборки элемента?](#27-Какая-оценка-временной-сложности-выборки-элемента-из-HashMap-Гарантирует-ли-HashMap-указанную-сложность-выборки-элемента)

[28. Роль equals и hashCode в HashMap?](#28-Роль-equals-и-hashCode-в-HashMap)

[29. Как и когда происходит увеличение количества корзин в HashMap?](#29-Как-и-когда-происходит-увеличение-количества-корзин-в-HashMap)

[30. Как работает HashMap?](#30-Как-работает-HashMap)

[31. Что такое хеш таблицы?](#31-Что-такое-хеш-таблицы)

[32. Что такое красно-черное дерево?](#32-Что-такое-красно-черное-дерево)

[33. Удаление элемента из дерева?](#33-Удаление-элемента-из-дерева)

[34. Какие существуют алгоритмы обхода дерева?](#34-Какие-существуют-алгоритмы-обхода-дерева)

[35. Перечислите побитовые логические операции которые Вы знаете?](#35-Перечислите-побитовые-логические-операции-которые-Вы-знаете)

Перечислите побитовые логические операции, которые Вы знаете? Расскажите, как они работают.

## 1. Что такое генерики?

Обобщенное программирование - это подход к описанию данных и алгоритмов, позволяющий использовать их с разными типами
данных без изменения их описания.

**Обобщения** - это параметризованные типы. С их помощью можно объявлять классы, интерфейсы и методы, где тип данных 
указан в виде параметра. 

Дженерики позволяют типам (классам и интерфейсам) быть параметрами при определении классов, интерфейсов и методов.
Это позволяет повторно использовать один и тот же код с разными входными типами данных.

В Java дженерики добавили для реализации обобщенных коллекций, безопасных с точки зрения типов.
Ошибка компиляции - это лучше, чем исключение `ClassCastException` в связи с неправильным приведением типов во время выполнения.
После компиляции какая-либо информация о дженериках стирается. Это называется "Стирание типов".
Также дженерики делают исходный код программы более удобочитаемым.

Свойства дженериков: строгая типизация, единая реализация, отсутствие информации о типе.

В `Java Collections Framework`используются обобщенные типы, например, класс типа `LinkedList<E>` - обобщенный тип. 
Параметр `<E>` предсталяет тип элементов, которые будут храниться в коллекции.

`LinkedList<String>`, `LinkedList<Integer>` - это параметризованные типы, а `String`, `Integer` - реальные типы аргументов.

наглядно из Effective Java:

![img](https://github.com/greenman777/job4j/blob/master/interview_questions/Generics.jpg)

[к оглавлению](#Collections-Pro)

## 2. Что такое wild cards?

Существует 2 типа дженериков:

+ **<Т> Обычные дженерики (параметризованные типы)** - представляет возможность указать в классе или методе 
неопределенный тип или несколько типов, дать ему имя, которое в дальнейшем можно использовать в рамках класса или метода, 
как эквивалентное оригинальному типу. 

    Может быть использован с ключевым словом `extends`, ограничен этим классом и его наследниками. 
Так же можно использовать & и/или | указать несколько классов и/или интерфейсов. 
Поддерживает рекурсивное расширение типов.

`public static class NumberContainer<T extends Number & Comparable> {`

+ **<?> Wildcard (подстановочные типы или маски)** - используются в сигнатуре методов, но для параметризации класса - нет! 
Может быть использован в сочитании ключевыми словами `extends` и `super`. Делятся на три типа:
    

    + Upper Bounded Wildcards `<? extends X>` - класс X или любой его сабкласс
    
    + Unbounded Wildcards `<?>` - любой класс. Недопустимы операции, изменяющие коллекцию/объект. Действует защита, так как тип содержимого коллекции неизвестен.
    
    + Lower Bounded Wildcards `<? super Y>` - класс Y или любой его суперкласс
    
Для выбора типа используют принцип PECS (`Producer Extends` `Consumer Super`)
+ `extends` - когда надо только получать данные из объекта. Метод передает данные в аргумент. (Producer)
+ `super` - когда надо надо только вставлять данные в объект. Метод читает данные из аргумента. (Consumer)
+ не нужно использовать `wildcard`, когда требуется и получать и вставлять данные в структуру. 

[к оглавлению](#Collections-Pro)

## 3. Где хранится информация про Generics?

Только в исходном коде до момента компиляции.
Компилятор стирает информацию о типе, заменяя все параметры без ограничений (unbounded) типом Object, а параметры с границами (bounded) — на эти границы. Это называется type erasure.

[к оглавлению](#Collections-Pro)

## 4. Как можно получить тип Generics?

Информация о параметрах generic-классов при компиляции существует только в информации о классе, который явно определяет значение параметра в его generic-родителе.
Узнать всё это нам поможет метод Class.getGenericSuperclass().

```java
public class FloatList extends ArrayList<Float>{}
ArrayList<Float> listOfNumbers = new FloatList();

Class actualClass = listOfNumbers.getClass();
ParameterizedType type = (ParameterizedType)actualClass.getGenericSuperclass();
System.out.println(type); // java.util.ArrayList<java.lang.Float>
Class parameter = (Class)type.getActualTypeArguments()[0];
System.out.println(parameter); // class java.lang.Float
```

[к оглавлению](#Collections-Pro)

## 5. Что такое итератор?

Это шаблон проектирования для прохода по всем элементам множества
Основные методы:
+ `hasNext()` - существует ли следующий элемент.
+ `next()` - возвращает сам элемет.

В стандартной библиотеке java существует 2 интерфейса это `Iterable` и `Iterator`. 
+ `Iterable` - вынуждает релизовать метод возвращающий итератор.
+ `Iterator` - вернуть объект итератора.

[к оглавлению](#Collections-Pro)

## 6. Что такое коллекции?

**Коллекции** - это хранилища, поддерживающие различные способы хранения и упорядочивания объектов с целью обеспечения эффективного доступа к ним.

Инструменты для работы с такими структурами в Java содержатся в Java Collections Framework. Фреймворк состоит из интерфейсов, их реализаций и утилитных классов для работы со списками: сортировки, поиска, преобразования. Т.е. это набор интерфейсов и реализующих их классов.

[к оглавлению](#Collections-Pro)

## 7. Назовите базовые интерфейсы коллекций?

+ **`Iterable`** - интерфейс наделяет класс возможностью перебирать объект этого класса, используя Iterator 
+ **`Collection`** - (наследуется от Iterable) коллекция содержит набор объектов (элементов). 
Здесь определены основные методы для манипуляции с данными, 
такие как вставка (`add`, `addAll`), удаление (`remove`, `removeAll`, `lear`), поиск (`contains`). 
+ **`Set`** - наследуюется от **Collection** - множество неповторяющихся элементов (Здесь могут храниться только уникальные значения, нет дубликатов).
+ **`List`** - наследуюется от **Collection** - упорядоченный список. В какой последовательности данные положили, в такой они и хранятся. Допускаются дубликаты.
+ **`Queue`** - наследуюется от **Collection** - очередь (FIFO первый вошел, первый вышел). реализует LinkedList и ArrayDeque.
+ **`SortedSet`** - наследуюется от **Set** -  отсортированный список уникальных объектов.

+ **`Map`** - карта, ассоциативный массив. Значения хранятся в виде пар ключ=значение. Каждому элементу из множества ключей соответствует множество значений. Ключи уникальные. По ключу получаем значение. У мапы нет итератора. Map не наследуется от Collection.

[к оглавлению](#Collections-Pro)

## 8. Расскажите реализации интерфейса List?

+ **`ArrayList`** - на массиве с несинхронизированными методами. Размер динамически изменяется. Когда внутренний массив элементов заполняется, ArrayList создает внутри себя новый массив. Его размер = (размер старого массива * 1,5) +1. Все данные копируются из старого массива в новый. 

+ **`Vector`** - на массиве с синхронизированными методами.

+ **`Stack`** - на массиве есть синхронизированные методы но не все. Stack является подклассом класса Vector, который реализует простой механизм типа "последний вошёл - первый вышел" (LIFO). Метод push() помещает объект в стек, а метод pop(), наоборот, вытаскивает объект из стека.

+ **`LinkedList`** - Является представителем двусвязного списка, где каждый элемент структуры содержит указатели на предыдущий и следующий элементы. Итератор поддерживает обход в обе стороны. Реализует методы получения, удаления и вставки в начало, середину и конец списка. Позволяет добавлять любые элементы в том числе и null.

[к оглавлению](#Collections-Pro)

## 9. Расскажите реализации интерфейса Set?

**`Set`** - набор/множество, не может содержать дубликаты.

+ **`HashSet`** - реализация интерфейса Set, базирующаяся на HashMap. Внутри использует объект HashMap для хранения данных. В качестве ключа используется добавляемый элемент, а в качестве значения — объект-пустышка (new Object()). Из-за особенностей реализации порядок элементов не гарантируется при добавлении.

+ **`LinkedHashSet`** - отличается от HashSet только тем, что в основе лежит LinkedHashMap вместо HashMap. Благодаря этому отличию порядок элементов при обходе коллекции является идентичным порядку добавления элементов. Требует больше памяти.

+ **`TreeSet`** - основан на сбалансированном двоичном дереве, в результате элементы упорядочены по возрастанию `hashCode()`'ов. Содержит в себе объект NavigableMap, что и обуславливает его поведение. Предоставляет возможность управлять порядком элементов в коллекции при помощи объекта Comparator, либо сохраняет элементы с использованием "natural ordering".

[к оглавлению](#Collections-Pro)

## 10. Расскажите реализации интерфейса Map?

+ **`Hashtable`** — реализация такой структуры данных, как хэш-таблица. Она не позволяет использовать null в качестве значения или ключа. Эта коллекция была реализована раньше, чем Java Collection Framework, но в последствии была включена в его состав. Методы синхронизированы, поэтому медленная.

+ **`HashMap`** - не синхронизированная хэш-таблица (быстрая). Null возможен в качестве ключа и значения. Данная коллекция не является упорядоченной: порядок хранения элементов зависит от хэш-функции.

+ **`LinkedHashMap`** - это упорядоченная реализация хэш-таблицы. Здесь, в отличии от HashMap, порядок итерирования равен порядку добавления элементов. Данная особенность достигается благодаря двунаправленным связям между элементами (аналогично LinkedList).

+ **`TreeMap`** -  реализация Map основанная на красно-чёрных деревьях. Как и LinkedHashMap является упорядоченной. По-умолчанию, коллекция сортируется по ключам с использованием принципа "natural ordering", но это поведение может быть настроено под конкретную задачу при помощи объекта Comparator, который указывается в качестве параметра при создании объекта TreeMap.

[к оглавлению](#Collections-Pro)

## 11. Отличие ArrayList от LinkedList?

**`ArrayList` - основан на динамическом массиве**, хранит свои элементы в массиве. 
(используют, если элементы чаще читаются, чем добавляются)

**+** Быстрая навигация по коллекции - осуществляется быстрый поиск элементов;

**+** меньше расходует памяти на хранение элементов;

**-** увеличение `ArrayList` происходит медленно;

**-** при вставке или удалении элемента в середину или в начало, приходится переписывать все элементы;

**`LinkedList` - двунаправленный список (цепочка)**, хранит элементы в объектах `Node<E>`, у которых есть ссылки на 
предыдущий и следующий элементы (используют, если элементы чаще добавляются, чем читаются) 

**+** быстрая вставка и удаление в середину списка (переписать `next` и `previous` и всё);

**-** долгий поиск в середине (нужно перебрать все элементы);

Очевидно, что плюсы одного являются минусами второго.
В среднем, сложности одинаковые, но все же ArrayList предпочтительнее использовать. 
`LinkedList` рекомендуется использовать, только когда преобладает удаление или вставка в начало или конец списка.

[к оглавлению](#Collections-Pro)

## 12. Отличие Set от List?

+ **`Set`** - множество, не хранит дубликаты. 

+ **`List`** - список, может содержать дубли.

[к оглавлению](#Collections-Pro)

## 13. Расскажите про методы Object hashCode и equals?

Метод `hashCode()` используется для числового представления объекта, метод `equals()` для сравнения двух объектов.
При переопределении метода `equals()` всегда переопределяют `hashCode()`.
Если метод `equals()` возвращает `true`, то `hashCode()` всегда равны, но не наоборот, потому что 
возможны коллизии, когда для разных объектов будет одинаковый `hashCode()`. *"Множество объектов мощнее множества хеш-кодов."* 
Множество возможных хеш-кодов ограничено диапазоном примитивного типа `int` `2^32`, а множество объектов ничем не ограничено. 
    
**Метод `equals()` переопределяется так:** 
1. Не равны ли ссылки.
2. Не равен `null`.
3. Проверяем что объекты от одного класса.
4. Не равны состояния полей.

```java
public boolean equals(Object o) {
        if (this == o) {
            return true;
        }
        if (o == null || getClass() != o.getClass()) {
            return false;
        }
        User user = (User) o;
        return children == user.children && name.equals(user.name) && birthday.equals(user.birthday);
    }
 ```   

**hashCode()** используется для повышения производительности. От качества его реализации зависит правильность сравнения объектов при вставке/поиске/удалении в Hash коллекциях, а так же насколько часто будут возникать коллизии.

Есть определенные правила при реализации hashCode

1) Если два объекта равны (т.е. метод equals() возвращает true), у них должен быть одинаковый хэш-код.

2) Если метод hashCode() вызывается несколько раз на одном и том же объекте, каждый раз он должен возвращать одно и то же число.

3) Если хэш-коды не равны, то и объекты считаются не равными.

4) Если хэш-коды равны, не обязательно, что равны объекты.

5) При переопреджелении equals всегда переопределяем hashCode

6) Все значимые поля объекта необходимо включить в вычисление хэш-кода. Это поможет снизить колличество коллизий в дальнейшем.

Для вычисления hashCode можно использовать статистческий метод Objects.hash(param1, param2....) либо выполнить свою реализацию.

При выполнении своей реализации лучше основываться на принципах:

1) Объявляем переменную типа int с именем result и инициализируем ее хеш-кодом с для первого значащего поля нашего объекта, например:

int result = name.hashCode();

2) Для каждого из остальных значащих полей выполняем следующее. Вычисляем хеш-код с типа int для такого поля. Для массивов каждый значащий элемент рассматриваем как отдельное поле. Объединяем хеш-код с, вычисленный result следующим образом:

result = 31 * result + с;

Все значащие поля должны быть учтены. Производные поля в функцию не включаем.


Получаем в итоге:

```java
@Override public int hashCode()

{

    int result = name.hashCode();

    result = 31* result + Integer.hashCode(children);

    result = 31 * result + birthday.hashCode();


    return result;

}
```

Либо используем готовую реализацию: 

```java
Objects.hash(param1, param2....)
```


[к оглавлению](#Collections-Pro)

## 14. Расскажите, что такое коллизии в Map Как с ними бороться?

**Хеширование** — преобразование массива входных данных произвольной длины в (выходную) битовую строку установленной длины, 
выполняемое по определенному алгоритму. Функция, воплощающая этот алгоритм и выполняющая преобразование, 
называется хеш-функцией. Хеш-код - это результат вычисления хеш-функции. 

**Коллизия** - эта такая ситуация, при которой для двух разных объектов (ключей) мы получаем один и тот же бакет (корзину).
Возникает оттого, что количество значений хеш-функций меньше (ограничены диапазоном значений типа `int 2^32`), чем вариантов исходных данных. 
Так же зависит от качества хеш-функций.

Рассмотрим, относительно чего бывают коллизии. Давайте еще раз вспомним, что происходит при добавлении в HashMap

1. Вычисляется hashCode()

2. Вычисляется значение хэш функции методом hash() в мапе

3. Получается индекс hash & (table.length - 1)

Очевидно, что на каждом из этих шагов выполняются арифметические операции => могу возникнуть коллизии => могут быть следующие причины коллизий:

1. относительно получения индекса, т.е. относительно оператора &. Например, если h1 = 1 и h2 = 17, h1 & 15 == h2 & 15

2. относительно hash() функции. Например, если хэш функция это сумма цифр, то hash(123) == hash(321). Это причина повлечет за собой коллизию как в случае 1

3. относительно hashCode(). Например, o1.hashCode() == o2.hasCode(). Это причина повлечет за собой коллизию как в случае 2

Если получение индекса мы изменить не можем, то hash() и hashCode() нам подвластны. Поэтому особое внимание уделяют этим методам. 

В Java для разрешения коллизий используется модифицированный метод цепочек. Суть: когда количество элементов в корзине 
превышает определенное значение, данная корзина переходит от использования связного списка к использованию 
сбалансированного дерева. Но данный метод имеет смысл лишь тогда, когда на элементах хеш-таблицы задан линейный порядок. 
Т.е. при использовании данных типа `int` или `double` имеет смысл переходить к дереву поиска, а при использовании 
каких-нибудь ссылок на объекты не имеет, т.к. они не реализуют нужный интерфейс. 
Такой подход позволяет улучшить производительность с `O(n)` до `O(log(n))`. 
Данный способ используется в таких коллекциях как `HashMap`, `LinkedHashMap` и `ConcurrentHashMap`.

По простому:

**Коллизия** - это когда для двух объектов вычисляется одинаковый хеш-код.
 
Решение: проверить методом `equals()`, что ссылки на объекты не равны. 
Для хэш-таблицы в ту же ячейку добавляется еще один объект, за счет того что каждая ячейка - это связанный список.

[к оглавлению](#Collections-Pro)

## 15. Расскажите что такое анализ алгоритма?

Анализ алгоритма дает нам понимание того, сколько времени займет решение данной задачи при помощи данного алгоритма. 
Эффективность алгоритма оценивается его временной сложностью.

При анализе алгоритма выбор входных данных может существенно повлиять на его выполнение. Практически нужно искать такие данные, которые обеспечивают как самое быстрое, так и самое медленное выполнение алгоритма. Анализ **наихудшего случая** чрезвычайно важен, поскольку он позволяет представить максимальное время работы алгоритма. При анализе наихудшего случая необходимо найти входные данные, на которых алгоритм будет выполнять больше всего работы.

Анализ **среднего случая** является самым сложным, поскольку он требует учета множества разнообразных деталей. Входные данные разбиваются на группы с одинаковой вероятностью. Среднее время работы вычисляется как сумма произведений вероятностей попадания данных в группу и времени работы алгоритмы для конкретной группы.

Временная сложность алгоритма – это функция, позволяющая определить, 
как быстро увеличивается время работы алгоритма с увеличением объёма данных.

Наиболее часто встречающиеся классы сложности:
+ `O(1)` – константная сложность (т.е. константное время);
+ `О(n)` – линейная сложность;
+ `О(nа)` – полиномиальная сложность;
+ `О(log(n))` – логарифмическая сложность;
+ `O(n*log(n))` – квазилинейная сложность;
+ `O(2n)` – экспоненциальная сложность;
+ `O(n!)` – факториальная сложность.

[к оглавлению](#Collections-Pro)

## 16. Какая временная сложность алгоритмов добавления, замены и удаления в каждой из коллекций С чем связаны отличия?

![img](https://github.com/johnivo/job4j/blob/master/interview_questions/src/main/resources/pro_2.png)

+ **`ArrayList`:** индекс - `O(1)`, поиск `O(n)`, вставка `O(n)`, удаление `O(n)`.

+ **`LinkedList`:** индекс - `O(n)`, поиск `O(n)`, вставка `O(1)`, удаление `O(1)`.

+ **Деревья** для всех операций - `O(log(n))`.

+ **Хэш таблицы** для всех операций - `O(1)`, если не считать коллизии.

Справочник по Java Collections Framework https://habr.com/ru/post/237043/

[к оглавлению](#Collections-Pro)

## 17. Расскажите реализации данных очередей и стеков?

+ **`Queue` (FIFO)** - одностороняя очередь, элементы можно получить в том порядке в котором добавляли.

+ **`Dequeue`** - двусторонняя очередь, можно вставлять/получать элементы из начала и конца. 

+ **`Stack` (LIFO)** - стек, можно получить только последний элемент.

```
Queue<Integer> myQ = new LinkedList<Integer>();
```

[к оглавлению](#Collections-Pro)

## 18. Расскажите про реализации деревьев?

+ **`TreeMap`** - упорядоченная по ключам. Основана на красно-черных деревьях. Может использовать компаратор в конструкторе. 
Красно-черные дерево - это самобалансирующееся дерево, которое гарантирует логарифмический рост высоты дерева от числа узлов.

+ **`TreeSet`** - основан на сбалансированном двоичном дереве, в результате элементы упорядочены по возрастанию хеш-кодов. 
Можно управлять порядком при помощи компаратора.

[к оглавлению](#Collections-Pro)

## 19. Что такое loadFactor?

**loadFactor** - это коэффициент загрузки, равен соотношению `(размер коллекции / колличество элементов)`. 
При достижении порогового значения размер коллекции увеличивается.

Например, в хеш-таблице поле, которое показывает на сколько заполнен массив, на котором эта таблица основана. 
Если на 3/4, то создается новый массив с большим размером и данные перераспределяются. 

[к оглавлению](#Collections-Pro)

## 20. Пример какова сложность поиска значения по ключу?

**Пример:** разработчик создал класс
```java
class User {
    private int age;
    private String name;
    private String email;

@Override
public boolean equals(Object o) {
    if (this == o) return true;
    if (o == null || getClass() != o.getClass()) return false;
    User user = (User) o;
    return age == user.age &&
    Objects.equals(name, user.name) &&
    Objects.equals(email, user.email);
}

@Override
public int hashCode() {
    return 1;
}
```
и затем создал 60 разных объектов которые использовал в качестве ключа в мапе
какова сложность поиска значения по ключу в таком случае и почему
java >= 1.8

**Ответ:**
Хеш-код у нас константа - худший вариант, т.е. все объекты находятся в одном бакете и хеш-таблица превращается в связный 
список со сложностью поиска `О(n)`. Т.к. версия java >= 1.8 то, когда количество элементов в бакете достигает 
определенной величины (`TREEIFY_THRESHOLD = 8`), вместо связанного списка используется сбалансированное дерево. 
Соответственно у нас `n=60 > 8`.

Поэтому в данном случае временная сложность поиска по ключу составит `О(log(n))`.

[к оглавлению](#Collections-Pro)

## 21. Расскажите правило для переопределения метода hashCode?

Необходимо перекрывать `hashCode` каждый раз, когда выполняется перекрытие `equals`, иначе программа может работать неправильно. 
Метод `hashCode` должен подчиняться общему контракту, определенному в `Object`, и выполнять разумную работу по назначению 
неравным экземплярам разных значений хеш-кодов. 

Главным условием при перекрытии метода `hashCode`: равные объекты должны давать одинаковый хеш-код. 
Два различных экземпляра с точки зрения метода `equals` могут быть логически эквивалентными, 
однако для метода `hashCode` класса `Object` оказаться всего лишь двумя объектами, не имеющими между собой ничего общего.

1. Объявить переменную типа `int` с именем `result` и инициализировать ее хеш-кодом с (identity hash code) 
для первого значащего поля объекта.

2. Для каждого из остальных значащих полей нужно:

    а. Вычислить хеш-код с типа `int` для такого поля.

    б. Объединить хеш-код с, вычисленный в п. 2, а, с `result` следующим образом: `result = 31 * result + с;`

3. Вернуть `result`.

Примечание: Производные поля можно из вычисления хеш-кода исключить, т.е. можно игнорировать любое поле, 
значение которого может быть вычислено из полей, включаемых в вычисления. Необходимо исключить любые поля, 
которые не используются в сравнении методом `equals`, иначе есть риск нарушить второе положение контракта `hashCode`. 
Умножение в п. 2б делает результат зависящим от порядка полей и дает гораздо лучшую хеш-функцию, 
если класс имеет несколько аналогичных полей. 
Значение 31 выбрано потому, что оно является нечетным простым числом, это традиционная практика, 
кроме того повышает производительность (умножение можно заменить сдвигом и вычитанием).

[к оглавлению](#Collections-Pro)

## 22. Приведите пример переопределения hashCode?

Например, переопределим `hashCode` для класса PhoneNumber:
```java
public final class PhoneNumber {
    private final short areaCode, prefix, lineNum;
    public PhoneNumber(int areaCode, int prefix, int lineNum) {
         this . areaCode = rangeCheck (areaCode, 999, ’’area code”);
         this.prefix = rangeCheck (pref ix, 999, ’’prefix’’);
         this.lineNum = rangeCheck(lineNum, 9999, "line num”);}

   // Типичный метод hashCode
   @Override public int hashCode() {
        int result = Short.hashCode(areaCode);
        result = 31* result + Short.hashCode(prefix);
        result = 31 * result + Short.hashCode(lineNum);
        return result;}

   // Однострочный метод hashCode с посредственной производительностью. Этот стиль хеш-функции рекомендуется использовать только в ситуациях, когда производительность не является критической.
   @Override public int hashCode() {
       return Objects.hash(lineNum, prefix, areaCode);}

   // Метод hashCode с отложенной инициализацией и кешированием хеш-кода. Если класс является неизменяемым, а стоимость вычисления хеш-функции имеет значение, вы можете подумать о хранении хеш-кода в самом объекте вместо того, чтобы вычислять его заново каждый раз, когда в нем появится необходимость.
   private int hashCode; // Автоматически инициализируется значением 0
  @Override public int hashCode() {
      int result = hashCode;
      if (result == 0) {
         result = Short.hashCode(areaCode);
         result =31* result + Short.hashCode(prefix) ;
         result =31* result + Short.hashCode(lineNum);
         hashCode = result;}
      return result;}

}
```

Контракт `hashCode` из спецификации `Object`:

+ Во время выполнения приложения при многократном вызове для одного и того же объекта метод `hashCode` 
должен всегда возвращать одно и то же целое число при условии, что никакая информация, 
используемая при сравнении этого объекта с другими методом equals, не изменилась. 
Однако не требуется, чтобы это же значение оставалось тем же при другом выполнении приложения.

+ Если два объекта равны согласно результату работы `equals(Object)`, то при вызове для каждого из них метода 
`hashCode` должны получиться одинаковые целочисленные значения.

+ Если метод `equals(Object)` утверждает, что два объекта не равны один другому, это не означает, что метод `hashCode` 
возвратит для них разные числа. Однако программист должен понимать, что генерация разных чисел для неравных 
объектов может повысить производительность хеш-таблиц.

[к оглавлению](#Collections-Pro)

## 23. Как вычисляется hash функция от объекта в HashMap?

```java
static final int hash(Object key) {
    int h;
    return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);
}
```
в методе `hash()` cначала вычисляется промежуточное значение `h`, 
оно равно хеш-функции от ключа (для `HashMap` в базовой реализации `Object.hashCode()`), 
затем вычисляется значение, равное нулевому побитовому сдвигу числа `h` вправо на 16 бит с заполнением нулями 
(`>>>` все биты числа сдвигаются вправо на 16 позиций, освободившиеся биты заполняются нулями), 
и для вычисленных выше значений выполняется операция `XOR` (^ побитовое логическое или).

В методе коллекции, при поиске бакета/корзины/индекса хеш-код ключа делится с остатком (`%`) на размер хеш-таблицы 
(по умолчанию `n=16`) и результатом будет число в диапазоне от `0` до `n`, 
т.е. номер ячейки в массиве, куда помещается объект с нашим ключом. 
А т.к. для `HashMap` размер хеш-таблицы равен степени 2, то вместо `%n` (остатка от деления) 
используется более быстрый `&(n-1)` (побитовое И).

Т.е. вместо `index = hash % (n - 1)` используется `index = (n - 1) & hash`

Примечание: побитовый сдвиг `>>>` и операция `XOR` выполняются для того, 
чтобы старшие биты первоначального хеш-кода `h` в дальнейшем участвовали в `(n - 1) & hash` даже при небольшом кол-ве бакетов. 
Этим обеспечивают не само по себе наилучшее распределение в хеш-таблице, а страхуются от неудачной функции `hashcode()`.

**Итого:** Через `%` или `&` вычисляется "внешний" `hash` (находим бакет/корзину/индекс в массиве),
 через `>>>` "внутренний", который отвечает за усложение хеш-кода, подключая к формированию старшие биты.

[к оглавлению](#Collections-Pro)

## 24. Правила проверки при переопределении метода equals?

**1.** Используйте оператор `==` для проверки того, что аргумент является ссылкой на данный объект. 
Если это так, возвращайте `true`. Это просто оптимизация производительности, 
которая может иметь смысл при потенциально дорогостоящем сравнении.

**2.** Используйте оператор `instanceof` для проверки того, что аргумент имеет корректный тип. 
Если это не так, возвращайте `false`. Обычно корректный тип — это тип класса, которому принадлежит данный метод. 
В некоторых случаях это может быть некоторый интерфейс, реализованный этим классом. Если класс реализует интерфейс, 
который уточняет контракт метода `equals`, то в качестве типа указывайте этот интерфейс: 
это позволит выполнять сравнение классов, реализующих этот интерфейс. 
Подобным свойством обладают интерфейсы коллекций, таких как `Set`, `List`, `Мар` и `Map. Entry`.

**3.** Приводите аргумент к корректному типу. Поскольку эта операция следует за проверкой instanceof, она гарантированно успешна.

**4.** Для каждого “важного” поля класса убедитесь, что значение этого поля в аргументе соответствует полю данного объекта. Если все тесты успешны, возвращайте true; в противном случае возвращайте false. Если в п. 2 тип определен как интерфейс, вы должны получить доступ к полям аргумента через методы интерфейса; если тип представляет собой класс, вы можете обращаться к его полям непосредственно, в зависимости от их доступности.

Пример Класс с типичным методом `equals`:
```java
public final class PhoneNumber {
   private final short areaCode, prefix, lineNum;
   public PhoneNumber(int areaCode, int prefix, int lineNum) {
      this . areaCode = rangeCheck (areaCode, 999, ’’area code”);
      this.prefix = rangeCheck (pref ix, 999, ’’prefix’’);
      this.lineNum = rangeCheck(lineNum, 9999, "line num”);}
   private static short rangeCheck(int val, int max, String arg) {
      if (val < 0 || val > max)
         throw new IllegalArgumentException (arg 4- ": "4- val);
         return (short) val;

   @Override public boolean equals(Object о) {
      if (о == this) //1
         return true;
      if (! (o instanceof PhoneNumber)) //2
         return false;

//здесь насколько понял, мы нарушаем принцип подстановки Лисков и используем следующее

      if (о == null || o.getClass() != getClass ())
         return false;


      PhoneNumber pn = (PhoneNumber)o; //3
      return pn.lineNum == lineNum && pn.prefix == prefix && pn.areaCode == areaCode; //4
      }
... 
}
```
метод `equals` имеет смысл перекрывать, когда для класса определено понятие логической эквивалентности 
(logical equality), которая не совпадает с тождественностью объектов, а в суперклассе метод equals не перекрыт. 
В общем случае это происходит с классами значений (напр. `Integer` или `String`). 
Перекрывая метод `equals`, нужно соблюдать его общий контракт.

Метод `equals` реализует отношение эквивалентности, которое обладает следующими свойствами:

+ Рефлексивность: для любой ненулевой ссылки на значение `х` выражение `х.equals(х)` должно возвращать `true`.

+ Симметричность: для любых ненулевых ссылок на значения `х` и `у` выражение `х.equals(у)` должно возвращать `true` 
тогда и только тогда, когда `у.equals(х)` возвращает `true`.

+ Транзитивность: для любых ненулевых ссылок на значения `х`, `у` и `z`, если `х.equals(у)` возвращает `true` 
и `у.equals(z)` возвращает `true`, `х.equals(z)` должно возвращать `true`.

+ Непротиворечивость: для любых ненулевых ссылок на значения `х` и `у` многократные вызовы `х.equals(у)` должны либо 
постоянно возвращать `true`, либо постоянно возвращать `false` при условии, что никакая информация, 
используемая в сравнениях `equals`, не изменяется.

+ Для любой ненулевой ссылки на значение `х` выражение `х.equals(null)` должно возвращать `false`.

[к оглавлению](#Collections-Pro)

## 25. Как устроена HashMap?

**`HashMap`** состоит из «корзин» `bucket`. С технической точки зрения бакеты — это элементы массива, которые хранят ссылки 
на списки элементов. При добавлении новой пары ключ-значение, вычисляет хеш-код ключа, на основании которого вычисляется 
номер корзины (номер ячейки массива), в которую попадет новый элемент. 

Если корзина пустая, то в нее сохраняется ссылка на вновь добавляемый элемент, если же там уже есть элемент, 
то происходит последовательный переход по ссылкам между элементами в цепочке, в поисках последнего элемента, 
от которого и ставится ссылка на вновь добавленный элемент. 

Если в списке был найден элемент с таким же ключом, то он заменяется. Добавление, поиск и удаление элементов выполняется 
за константное время. Вроде все здорово, с одной оговоркой, хеш-функция должна равномерно распределять элементы 
по корзинам, в этом случае временная сложность для этих 3 операций будет не ниже `lg т`, 
а в среднем случае как раз константное время.

[к оглавлению](#Collections-Pro)

## 26. Какое начальное количество корзин в HashMap?

По умолчанию в `HashMap` 16 корзин. Отвечая, стоит заметить, что можно используя конструкторы с параметрами: 
через параметр `capacity` задавать свое начальное количество корзин

[к оглавлению](#Collections-Pro)

## 27. Какая оценка временной сложности выборки элемента из HashMap Гарантирует ли HashMap указанную сложность выборки элемента?

Если вы возьмете хеш-функцию, которая постоянно будет возвращать одно и то же значение, то `HashMap` превратится 
в связный список, с низкой производительностью.
 
Если вы будете использовать хеш-функцию с равномерным распределением, в предельном случае гарантироваться будет только 
временная сложность `lg n`. Так что, ответ на вторую часть вопроса — нет, не гарантируется.

[к оглавлению](#Collections-Pro)

## 28. Роль equals и hashCode в HashMap?

`hashCode` позволяет определить корзину для поиска элемента, а `equals` используется для сравнения ключей элементов 
в списке внутри корзины и искомого ключа.

[к оглавлению](#Collections-Pro)

## 29. Как и когда происходит увеличение количества корзин в HashMap?

Помимо `capacity` в `HashMap` есть еще параметр `loadFactor`, на основании которого, вычисляется предельное количество 
занятых корзин (`capacity*loadFactor`). По умолчанию `loadFactor = 0,75`. По достижению предельного значения, 
число корзин увеличивается в 2 раза. Для всех хранимых элементов вычисляется новое «местоположение» с учетом нового 
числа корзин.

[к оглавлению](#Collections-Pro)

## 30. Как работает HashMap?

HashMap имеет внутренний класс **Entry**:
```java
static class Entry<K ,V> implements Map.Entry<K, V> {
	final K key;
	V value;
	Entry<K ,V> next;
	final int hash;
}
```
**How HashMap.put() методы работы:**

transient Entry[] table;		
1. Прежде всего, ключевой объект проверяется на null. Если ключ равен null, значение сохраняется в позиции таблицы[0].
Потому что хэш-код для null всегда равен 0.
2. Затем на следующем шаге хэш-значение вычисляется с использованием хэш-кода ключа путем вызова его метода hashCode().
Это хэш-значение используется для вычисления индекса в массиве для хранения объекта Entry.
Разработчики JDK хорошо предположили, что могут существовать некоторые плохо написанные функции hashCode(), которые могут возвращать очень высокое или низкое значение хэш-кода.
Чтобы решить эту проблему, они ввели другую функцию hash() и передали хэш-код объекта этой функции hash(), чтобы привести хэш-значение в диапазон размера индекса массива.
3. Теперь **indexFor(hash, table.length)** функция вызывается для вычисления точного положения индекса для хранения объекта ввода.

**Как разрешаются коллизии:**

Поскольку мы знаем, что два неодинаковых объекта могут иметь одинаковое значение хэш-кода, как два разных объекта будут храниться в одном и том же местоположении массива, называемом bucket.
Ответ - LinkedList. Если вы помните, у начального класса был атрибут "next".
Этот атрибут всегда указывает на следующий объект в цепочке. Именно так ведет себя LinkedList.

1. Таким образом, в случае коллизий объекты сохраняются в форме связанного списка.
Когда объект записи необходимо сохранить в определенном индексе, HashMap проверяет, существует ли уже запись?
+ Если запись еще не присутствует, объект сохраняется в этом расположении, next = null.
+ Если объект уже находится в вычисляемом индексе, объекты сравниваются по ключу на hash и equals. Если равны, то заменяется, иначе проверяется next.
+ Если он равен null, текущий объект записи становится следующим узлом в linkedlist.
+ Если следующая переменная не равна null, процедура выполняется до тех пор, пока следующая не будет оценена как null или не найдётся равный объект по ключу.

Как работают методы HashMap.get():
```java
public V get(Object key) {
    if (key == null)
    return getForNullKey();
    int hash = hash(key.hashCode());
    for (Entry<K , V> e = table[indexFor(hash, table.length)]; e != null; e = e.next) {
		Object k;
		if (e.hash == hash && ((k = e.key) == key || key.equals(k)))
			return e.value;
		}
		return null;
	}
}
```

[к оглавлению](#Collections-Pro)

## 31. Что такое хеш таблицы?

Хеш-таблицей называется структура данных, обеспечивающая очень быструю вставку и поиск. 
У хеш-таблиц также имеются свои недостатки. Они реализуются на базе массивов, а массивы трудно расширить после создания. 
У некоторых разновидностей хеш-таблиц быстродействие катастрофически падает при заполнении таблицы, 
поэтому программист должен довольно точно представлять, сколько элементов данных будет храниться в таблице 
(или приготовиться к периодическому перемещению данных в другую хеш-таблицу большего 
размера — процесс занимает довольно много времени).

Кроме того, при работе с хеш-таблицами не существует удобного способа перебора элементов в определенном 
порядке (скажем, от меньших к большим). Если вам необходима такая возможность, поищите другую структуру данных.

[к оглавлению](#Collections-Pro)

## 32. Что такое красно-черное дерево?

![img](https://github.com/greenman777/job4j/blob/master/interview_questions/tree_redblack.png)

Красно-черные деревья относятся к сбалансированным бинарным деревьям поиска.
Как бинарное дерево, красно-черное обладает свойствами:

1) Оба поддерева являются бинарными деревьями поиска.

2) **Для каждого узла с ключом K выполняется критерий упорядочения:
ключи всех левых потомков <= K < ключи всех правых потомков**
(в других определениях дубликаты должны располагаться с правой стороны либо вообще отсутствовать). 
Это неравенство должно быть истинным для всех потомков узла, а не только его дочерних узлов.

Свойства красно-черных деревьев:
1) Каждый узел окрашен либо в красный, либо в черный цвет (в структуре данных узла появляется дополнительное поле – бит цвета).
2) Корень окрашен в черный цвет.
3) Листья(так называемые null-узлы) окрашены в черный цвет.
4) Каждый красный узел должен иметь два черных дочерних узла. Нужно отметить, что у черного узла могут быть черные 
дочерние узлы. Красные узлы в качестве дочерних могут иметь только черные.
5) Пути от узла к его листьям должны содержать одинаковое количество черных узлов(это черная высота).

Красно-черные деревья: коротко и ясно https://habr.com/ru/post/330644/

[к оглавлению](#Collections-Pro)

## 33. Удаление элемента из дерева?

Если у удаляемого элемента нет потомков или один потомок, то удаленить просто. 
Если у удаляемого элемента есть два потомка, то удаляемый узел надо заменить на приемника. 
Т.к. используется сложный алгоритм для поиска приемника, то часто вместо удаления используют флаг `isDeleted`. 
В остальных методах проверяют значение этого флага.

[к оглавлению](#Collections-Pro)

## 34. Какие существуют алгоритмы обхода дерева?

В зависимости от траекторий выделяют два типа обхода:
+ горизонтальный (в ширину)
+ вертикальный (в глубину).

 **Горизонтальный** обход подразумевает обход дерева по уровням (level-ordered) – вначале обрабатываются все узлы 
текущего уровня, после чего осуществляется переход на нижний уровень.

```java
static void contLevelOrder(Node top) {
    Queue<Node> queue=new LinkedList<> ();
        do {
            top.treatment();
            if (top.left!=null) queue.add(top.left);
            if (top.right!=null) queue.add(top.right);
            if (!queue.isEmpty()) top=queue.poll();
    } while (!queue.isEmpty());
}
```
    
**Вертикальный** бывает 3 видов:
+ прямой (preorder)
    1. Посещение узла.
    2. Вызов самого себя для обхода левого поддерева узла.
    3. Вызов самого себя для обхода правого поддерева узла

+ симметричный (inorder). При симметричном обходе двоичного дерева все узлы перебираются в порядке возрастания ключей.
Простейший способ обхода основан на использовании рекурсии. 
Метод должен выполнить только три операции:
    1. Вызов самого себя для обхода левого поддерева узла.
    2. Посещение узла.
    3. Вызов самого себя для обхода правого поддерева узла. 
```java
private void inOrder(node localRoot) {
     if(localRoot != null) {
          inOrder(localRoot.leftChild);
          console.log(node.value);
          inOrder(localRoot.rightChild);
     }
}        
```

+ обратный (postorder)
    1. Вызов самого себя для обхода левого поддерева узла.
    2. Вызов самого себя для обхода правого поддерева узла.
    3. Посещение узла.

[к оглавлению](#Collections-Pro)

## 35. Перечислите побитовые логические операции которые Вы знаете?

![img](https://github.com/greenman777/job4j/blob/master/interview_questions/bin_operation.jpeg)
![img](https://github.com/greenman777/job4j/blob/master/interview_questions/bin_result.jpg)

[к оглавлению](#Collections-Pro)

## Источники:

**Generics** 

https://docs.oracle.com/javase/tutorial/java/generics/why.html

Пришел, увидел, обобщил: погружаемся в Java Generics 
https://habr.com/ru/company/sberbank/blog/416413/

Generics в Java 1.5
http://rsdn.org/article/java/genericsinjava.xml#EQNAC

Дженерики (Generics) в java 
https://www.fandroid.info/dzheneriki-generics-v-java/

Использование generic wildcards для повышения удобства Java API 
https://habr.com/ru/post/207360/

Примеры https://o7planning.org/ru/10403/java-generics-tutorial

Александр Маторин — Неочевидные Дженерики https://www.youtube.com/watch?v=_0c9Fd9FacU

Введение в Java. Generics. Wildcards | Технострим https://www.youtube.com/watch?v=FRmgcBxJvb4

Advanced Java - Generics https://www.youtube.com/playlist?list=PL6jg6AGdCNaX1yIJpX4sgALBTmTVc_uOJ
