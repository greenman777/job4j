## Collections Lite

#### part 2. [Collections Pro](CollectionsPro.md#collections-pro)

[1. Что такое коллекция?](#1-Что-такое-коллекция)

[2. Назовите преимущества использования коллекций?](#2-Назовите-преимущества-использования-коллекций)

[3. Какие данные могут хранить коллекции?](#3-Какие-данные-могут-хранить-коллекции)

[4. Какие есть типы коллекций? Как они характеризуются?](#4-Какие-есть-типы-коллекций-Как-они-характеризуются)

[5. Назовите основные реализации List, Set, Map?](#5-Назовите-основные-реализации-List,-Set,-Map)

[6. В чём отличие ArrayList от LinkedList?](#6-В-чём-отличие-ArrayList-от-LinkedList)

[7. В чём отличие HashSet от TreeSet?](#7-В-чём-отличие-HashSet-от-TreeSet)

[8. В чём отличие Set от Map?](#8-В-чём-отличие-Set-от-Map)

[9. Как задается порядок следования объектов в коллекции? Как отсортировать коллекцию?](#9-Как-задается-порядок-следования-объектов-в-коллекции-Как-отсортировать-коллекцию)

[10. Чем отличается Comparable от Comparator?](#10-Чем-отличается-Comparable-от-Comparator)

[11. Что такое сортировка по принципу Natural Order?](#11-Что-такое-сортировка-по-принципу-Natural-Order)

[12. Что такое equals и hashcode?](#12-Что-такое-equals-и-hashcode)

[13. Какие есть способы перебора всех элементов List?](#13-Какие-есть-способы-перебора-всех-элементов-List)

[14. Как реализован цикл foreach?](#14-Как-реализован-цикл-foreach)

[15. В чем разница между Iterator и ListIterator?](#15-В-чем-разница-между-Iterator-и-ListIterator)

[16. Как происходит удаление элементов из ArrayList?](#16-Как-происходит-удаление-элементов-из-ArrayList)

[17. Как происходит удаление элементов из LinkedList?](#17-Как-происходит-удаление-элементов-из-LinkedList)

[18. Расскажите иерархию интерфейсов Collections framework?](#18-Расскажите-иерархию-интерфейсов-Collections-framework)

[19. Назовите основные методы интерфейса Collections?](#19-Назовите-основные-методы-интерфейса-Collections)

[20. Может ли null использоваться в качестве ключа в Map?](#20-Может-ли-null-использоваться-в-качестве-ключа-в-Map)

[21. Может ли Set содержать null?](#21-Может-ли-Set-содержать-null)

[22. Как преобразовать массив строк в ArrayList?](#22-Как-преобразовать-массив-строк-в-ArrayList)

[23. Как отсортировать список в обратном порядке?](#23-Как-отсортировать-список-в-обратном-порядке)

[24. Какие реализации SortedSet вы знаете и в чем их особенность?](#24-Какие-реализации-SortedSet-вы-знаете-и-в-чем-их-особенность)

[25. В каких случаях разумно использовать массив, а не ArrayList?](#25-В-каких-случаях-разумно-использовать-массив-а-не-ArrayList)

[26. Какие коллекции синхронизированы?](#26-Какие-коллекции-синхронизированы)

[27. Расскажите о методах Map](#27-Расскажите-о-методах-Map)

[28. Расскажите, какие классы реализовывают интерфейс Map?](#28-Расскажите,-какие-классы-реализовывают-интерфейс-Map)

[29. Расскажите о методах map.keySet и map.entrySet? Что такое Entry?](#29-Расскажите-о-методах-map.keySet-и-map.entrySet?-Что-такое-Entry?)

[30. Что будет если вызвать метод map.put несколько раз с одинаковым ключем?](#30-Что-будет-если-вызвать-метод-map.put-несколько-раз-с-одинаковым-ключем?)

[31. В чем разница между Iterator и Iterable?](#31-В-чем-разница-между-Iterator-и-Iterable?)

## 1. Что такое коллекция?

**Коллекции** - это хранилища, поддерживающие различные способы хранения и упорядочивания объектов с целью обеспечения 
эффективного доступа к ним.

Инструменты для работы с такими структурами в Java содержатся в Java Collections Framework. Фреймворк состоит из интерфейсов, их реализаций и утилитарных классов для работы со списками: сортировки, поиска, преобразования. Т.е. это набор интерфейсов и реализующих их классов.

[к оглавлению](#collections-lite)

## 2. Назовите преимущества использования коллекций?

+ отсутствует необходимость следить за размерами коллекции (в отличае от массива);

+ имеют унифицированный API.

+ позволяют сократить количество кода и требуют меньше усилий для реализации, т.к. в коллекциях реализовано 
много методов по добавлению, удалению, сортировке элементов и т.п.;

+ если правильно подобрать коллекцию, то можно увеличить производительность программы;

+ упрощают взаимодействие разных частей программы, т.к. являются универсальным способом хранения и передачи данных.

+ предлагают различные структуры данных, упорядоченные, уникальные, отображения, деревья, очереди и другие для удобства работы с данными

[к оглавлению](#collections-lite)

## 3. Какие данные могут хранить коллекции?

Коллекции могут хранить любые ссылочные типы данных - то есть, ссылки на объекты. Если нужно хранить числа, их придется «оборачивать» в Integer, Double и т.д.

[к оглавлению](#collections-lite)

## 4. Какие есть типы коллекций Как они характеризуются?

+ **Set** - множество неповторяющихся элементов (Здесь могут храниться только уникальные значения, нет дубликатов)

+ **Queue** (Deque) - очередь (FIFO первый вошел, первый вышел). реализует LinkedList

+ **List** - упорядоченный список (В какой последовательности данные положили, в такой они и хранятся.
Допускаются дубликаты.)

+ **Map** - карта, ассоциативный массив (Значения хранятся в виде пар ключ=значение. Каждому элементу из множества
ключей соответствует множество значений. Ключи уникальные. По ключу получаем значение. У мапы нет итератора. 
Map не наследуется от Collection.) 

![Иерархия коллекций](https://github.com/greenman777/job4j/blob/master/interview_questions/Collection2.png)

Справочник по Java Collections Framework https://habr.com/ru/post/237043/

[к оглавлению](#collections-lite)

## 5. Назовите основные реализации List, Set, Map?

+ **List:** ArrayList, LinkedList

+ **Set:** HashSet, LinkedHashSat, TreeSet

+ **Map:** HashMap, LinkedHashMap, TreeMap

[к оглавлению](#collections-lite)

## 6. В чём отличие ArrayList от LinkedList?

**ArrayList - основан на динамическом массиве**, хранит свои элементы в массиве. 
(используют, если элементы чаще читаются, чем добавляются)

**+** Быстрая навигация по коллекции - осуществляется быстрый поиск элементов;

**+** меньше расходует памяти на хранение элементов;

**-** увеличение `ArrayList` происходит медленно;

**-** при вставке или удалении элемента в середину или в начало, приходится переписывать все элементы;

**LinkedList - двунаправленный список (цепочка)**, хранит элементы в объектах `Node<E>`, у которых есть ссылки на 
предыдущий и следующий элементы (используют, если элементы чаще добавляются, чем читаются) 

**+** быстрая вставка и удаление в середину списка (переписать `next` и `previous` и всё);

**-** долгий поиск в середине (нужно перебрать все элементы);

Очевидно, что плюсы одного являются минусами второго.
В среднем, сложности одинаковые, но все же `ArrayList` предпочтительнее использовать. 
`LinkedList` рекомендуется использовать, только когда преобладает удаление или вставка в начало или конец списка.

[к оглавлению](#collections-lite)

## 7. В чём отличие HashSet от TreeSet?

**Set** - множество неповторяющихся элементов.

**HashSet** хранит данные в произвольном порядке (хранит свои значения как ключи `HashMap`).

**TreeSet** хранит данные в отсортированном виде (в основе реализации бинарное красно-черное дерево).

[к оглавлению](#collections-lite)

## 8. В чём отличие Set от Map?

Главное отличие между **Set** и **Map**:  **Set** это подтип интерфейса коллекции, а **Map** не является подтипом интерфейса коллекции.
**Set** - это интерфейс, расширяющий интерфейс Collection. Он не может содержать повторяющиеся значения.
**Map** - это интерфейс, представляющий отображение между ключом и значением. Он не расширяет интерфейс Коллекции. Поэтому поведение Map отличается от обычных типов Collection. Карта не может содержать дубликаты ключей, и каждый ключ может отображать не более одного значения.

А ещё **Set** это список ключей от **Map**.

[к оглавлению](#Collections-Lite)

## 9. Как задается порядок следования объектов в коллекции Как отсортировать коллекцию?

Порядок задается либо естественным следованием элементов (natural order), 
либо объектом, реализующим интерфейс сравнения `Comparator`.

Можно отсортировать с помощью интерфейса `Comparable` или интерфейса `Comparator`:
 
+ Если объекты коллекции поддерживают интерфейс `Comparable`, то через `Collections.sort(collection)`; 

+ Если нет, то у коллекции вызвать метод `sort()` и передать ему `Comparator` в качестве аргумента `collection.sort(new MyComparator())`.
Либо использовать метод `Collections.sort(collection, new MyComparator())`.

[к оглавлению](#collections-lite)

## 10. Чем отличается Comparable от Comparator?

**Comparable** - используется только для сравнения объектов класса, в котором данный интерфейс реализован. 
Т.е. интерфейс `Comparable` определяет логику сравнения объектов определенного ссылочного типа внутри своей 
реализации (по правилам разработчика). 
`Collections.sort(collection);`

**Comparator** - представляет отдельную реализацию и ее можно использовать многократно и с различными классами. 
Т.е. интерфейс `Comparator` позволяет создавать объекты, которые будут управлять процессом сравнения: 
1. при сортировках в методах `Collections.sort(collection, new MyComparator())`, `Arrays.sort(array, new MyComparator())` 
или `collection.sort(new MyComparator())`
2. при управлении порядком в отсортированных множествах `TreeSet` или отсортированных картах `TreeMap`,
 например `new TreeSet<T> (new MyComparator())`.

**Разница:**

+ `Comparable` определяет логику сравнения объектов определенного ссылочного типа внутри своей реализации 
и, если нет доступа к исходникам, ее невозможно изменить. 

+ `Comparator` позволает определить логику сравнения объектов определенного ссылочного типа вне реализации 
этого типа и эту логику можно в любой момент подменить.

*`Comparable` используется для `natural ordering`, а `Comparator` для `total ordering`.*

**Примеры:**

http://java-online.ru/blog-comparator.xhtml

https://netjs.blogspot.com/2015/10/difference-between-comparable-and-comparator-java.html

https://www.programcreek.com/2011/12/examples-to-demonstrate-comparable-vs-comparator-in-java/

[к оглавлению](#collections-lite)

## 11. Что такое сортировка по принципу Natural Order?

Некоторые классы из коробки реализуют естественный порядок `natural order` для сортировки:

+ строки - лексикографический (по алфавиту),
+ числа - числовой, знаковый или без (больше меньше),
+ дата - хронологичский (по датам),
+ файл - лексикографический по имени пути
+ boolean - false < true

Остальные классы нужно руками делать `Comparable` или `Comparator`.

[к оглавлению](#collections-lite)

## 12. Что такое equals и hashcode?

Методы, необходимые для определения равенства объектов. 

`hashcode` возвращает число, являющееся уникальным идентификатором объекта. 
Это алгоритм, который позволяет множество значений объектов сузить до какого-то натурального количества.
 
`equals` сравнивает объекты по значению их полей. 

Объекты всех коллекций в названии которых есть *Hash...* должны иметь `hashcode` и `equals`.

[к оглавлению](#collections-lite)

## 13. Какие есть способы перебора всех элементов List?

Есть список стран, его нужно перебрать
```java
List<String> countries = Arrays.asList("Russia", "Panama", "Australia");
```
+ **циклы** `for`, `while`, `foreach`

```java
for (int i = 0; i < countries.size(); i++) {
    System.out.println(countries.get(i));
}
```

```java
int i = 0;
while (i < countries.size()){
    System.out.println(countries.get(i++));
}
```

```java
for (String country : countries) {
    System.out.println(country);
}    
```

+ **итераторы** `Iterator`, `ListIterator`
```java
Iterator<String> countriesIterator = countries.iterator();
while(countriesIterator.hasNext()) {
    System.out.println(countriesIterator.next());
}
```

```java
ListIterator<String> listIterator = countries.listIterator();
//в прямом порядке
while(listIterator.hasNext()) {
    System.out.println(listIterator.next());
}
//в обратном порядке
while(listIterator.hasPrevious()) {
    System.out.println(listIterator.previous());
}    
```
Если вызвать метод `next()` итератора, указывающего на последний элемент в коллекции, 
то возникнет исключение `NoSuchElementException`. Следует это помнить и использовать метод `hasNext()` перед вызовом `next()`.

+ **функция `forEach()`** 
    
    + **`Iterable.forEach()`** можно использовать для итерации по элементам списка начиная с Java 8. 
Этот метод определен в интерфейсе Iterable и может принимать лямбда-выражения в качестве параметра.
    ```java
    countries.forEach(System.out::println);
    ```
    
    + **`Stream.forEach()`** Мы также можем преобразовать коллекцию значений в поток и получить доступ 
    к таким операциям, как `forEach()`, `map()`, или `filter()`.
    ```java
    countries.stream().forEach(
        (c) -> System.out.println(c)
    );
    ```
    
https://www.codeflow.site/ru/article/java-iterate-list    

[к оглавлению](#collections-lite)

## 14. Как реализован цикл foreach?

`foreach` реализован на основе `Iterator`, т.е. он работает для классов, реализующих интерфейс `Iterable`.

(И наоборот, если коллекция `extends` от `Iterable`, то мы можем перебирать элементы этой коллекции с помощью `foreach`)

[к оглавлению](#collections-lite)

## 15. В чем разница между Iterator и ListIterator?

`ListIterator` расширяет `Iterator`, отличия следующие:

+ `Iterator` может использоваться для перебора элементов коллекций `Set`, `List` и `Map`. 
`ListIterator` может быть использован только для перебора элементов коллекции `List`

+ `Iterator` позволяет перебирать элементы только в одном направлении, при помощи метода `next()`. 
`ListIterator` позволяет перебирать список в обоих направлениях, при помощи методов `next()` и `previous()`.

+ `ListIterator` позволяет модифицировать список, добавляя/заменяя/удаляя элементы с помощью методов `add()`, `set()`
`remove()`. Iterator не поддерживает данного функционала.

[к оглавлению](#collections-lite)

## 16. Как происходит удаление элементов из ArrayList?

Находится заданный элемент. 
Далее сдвигаются влево на один элемент все последующие (с большим индексом) элементы, а значение `size` уменьшается на 1.

Непосредственно под капотом: 
```java
System.arraycopy(es, i + 1, es, i, newSize - i)
es[size = newSize] = null;
```

[к оглавлению](#collections-lite)

## 17. Как происходит удаление элементов из LinkedList?

Заменяются ссылки `previous` и `next` у соседних элементов.

[к оглавлению](#collections-lite)

## 18. Расскажите иерархию интерфейсов Collections framework?

![Иерархия коллекций](https://github.com/greenman777/job4j/blob/master/interview_questions/Collection1.jpg)

+ interface **`Collections`** extends **`Iterable`**.
    + interface `Set` (коллекция без дублирования)
        + `HashSet` базирующаяся на `HashMap` В качестве ключа используется добавляемый элемент, 
        а в качестве значения — объект-пустышка (new Object())
        + `LinkedHashSet` в основе лежит `LinkedHashMap`
    + interface `SortedSet` Методы: `first()`, `last()`
        + `TreeSet` (отсортированный список) содержит в себе объект `NavigableMap`.
    + interface `Queue` очередь Методы: `offer()`, `element()`, `peek()`, `poll()`, `remove()`.
    + interface `Deque` двусторонняя очередь `addFirst()`, `addLast()`, `getFist()`, `getLast()`, 
    (`push()`, `pop()` -> использовать как стек)
    + interface `List` упорядоченная коллекция (сохраняет последовательность элементов. можно получить по индексу, можно 
    повторяющиеся, можно по значению первый найденный)
    + `Vector` @deprecated реализация динамического массива объектов. Позволяет хранить любые данные, включая `null` 
    в качестве элемента
        + `Stack` - данная коллекция является расширением коллекции `Vector`. реализация стека `LIFO`.
        + `ArrayList` динамический массив, можно хранить `null`
        + `LinkedList` связный список (implementation `List` & `Deque`)
+ interface **`Map`** (нет итератора, нельзя перебирать в цикле. Можно получить представление в виде коллекции для перебора) 
`get()`, `put()`, `entrySet()`, `keySet()`, `values()`.
    + interface `SortedMap` (по порядку нарастания ключей)
    + interface `NavigableMap`
        + `TreeMap` реализация `Map` основанная на красно-чёрных деревьях (отсортированная по умолчанию `natural odering`, 
        можно задать свой компаратор)
    + `AbstractMap`
    + `HashMap` позволяет использовать `null` как в качестве ключа, так и значения
        + LinkedHashMap  это упорядоченная реализация хэш-таблицы. Аналогично `LinkedList`
    + `WeekHashMap` - реализация хэш-таблицы, которая организована с использованием weak references. 
Другими словами, `Garbage Collector` автоматически удалит элемент из коллекции при следующей сборке мусора, если на ключ 
этого элеметна нет жёстких ссылок

Справочник по Java Collections Framework https://habr.com/ru/post/237043/

[к оглавлению](#Collections-Lite)

## 19. Назовите основные методы интерфейса Collections?

### Основные
`boolean add(E obj)` - добавляет obj к вызывающей коллекции. Возвращает true, если obj был добавлен к коллекции.

`int size()` - возвращает количество элементов, содержащихся в коллекции. 

`void clear()` - удаляет все элементы вызывающей коллекции. 

`boolean contains(Object obj)` - возвращает true, если obj является элементом вызывающей коллекции. В противном случае возвращает false.

`boolean remove(Object obj)` - удаляет один экземпляр obj из вызывающей коллекции. Возвращает true, если элемент удален. В противном случае возвращает false.

`boolean equals(Object obj)` - возвращает true, если вызывающая коллекция и obj эквивалентны. В противном случае возвращает false.

`int hashCode()` - возвращает хешкод вызывающей коллекции. 

`boolean isEmpty()` - возвращает true, если вызывающая коллекция пуста. В противном случае возвращает false. 

`Iterator<E> iterator()` - возвращает итератор для вызывающей коллекции. 

### Дополнительные
`boolean retainAll(Collection<?> с)` - удаляет все элементы кроме входящих из вызывающей коллекции. Возвращает true, если в результате коллекция изменяется (то есть элементы удалены). В противном случае возвращает false. 

`boolean containsAll(Collection<?> с)` - возвращает true, если вызывающая коллекция содержит все элементы с. В противном случае возвращает false.

`boolean addAll(Collection<? extends Е> с)` - добавляет все элементы  к вызывающей коллекции. Возвращает true, если операция удалась (то есть все элементы добавлены). В противном случае возвращает false.

`Object[] toArray()` - возвращает массив, содержащий все элементы вызывающей коллекции. Элементы массива являются копиями элементов коллекции.

`boolean removeAll(Collection<?> с)` - удаляет все элементы из вызывающей коллекции. Возвращает truе, если в результате коллекция изменяется (то есть элементы удалены). В противном случае возвращает false. 

`removeIf(Predicate<? super E> filter)` - удаляет элементы из коллекции, соответствующие заданному условию.

[к оглавлению](#Collections-Lite)

## 20. Может ли null использоваться в качестве ключа в Map?

`HashMap` оперирует с `null`-ключом без каких-либо проблем. Его `hash` всегда равен `0`. 

В пустой `TreeMap` можно положить единственный `null`-ключ, 
все остальные операции (кроме `size()` и `clear()`, кстати) после этого не работают. 

В непустой `TreeMap` положить `null`-ключ нельзя из-за обязательного вызова `compareTo()`.

[к оглавлению](#Collections-Lite)

## 21. Может ли Set содержать null?

для `HashSet` работает. `TreeSet` — только для первого элемента.

[к оглавлению](#Collections-Lite)

## 22. Как преобразовать массив строк в ArrayList?

```java
Arrays.asList(words)
```

[к оглавлению](#Collections-Lite)

## 23. Как отсортировать список в обратном порядке?

```java
List reversedList = Collections.reverse(list)
```

[к оглавлению](#Collections-Lite)

## 24. Какие реализации SortedSet вы знаете и в чем их особенность?

`TreeSet` - в основе лежит красно-черное дерево, которое умеет само себя балансировать.

`TreeSet` все равно в каком порядке вы добавляете в него элементы, преимущества этой структуры данных будут сохраняться.

[к оглавлению](#Collections-Lite)

## 25. В каких случаях разумно использовать массив, а не ArrayList?

Рекомендация от Oracle: используйте `ArrayList` вместо массивов. 

Если ответить на этот вопрос нужно по-другому, то можно сказать следующее: 
Массивы могут быть быстрее и кушать меньше памяти. 
Списки теряют в производительности из-за возможности автоматического увеличения размера и сопутствующих проверок.

[к оглавлению](#Collections-Lite)

## 26. Какие коллекции синхронизированы?

Для этого используется пакет `Concurrent`. А также `@Deprecated` `HashTable`, `Vector`.

Получение синхронизированной коллекции из не синхронизированной:
```java
Collections.synchronizedList(list);
Collections.synchronizedSet(set);
Collections.synchronizedMap(map);
```

Получение коллекции только для чтения:
```java
Collections.unmodifiableList(list);
Collections.unmodifiableSet(set);
Collections.unmodifiableMap(map);
```

[к оглавлению](#Collections-Lite)

## 27. Расскажите о методах Map.

`void clear()` - Удаляет все пары ключей/значений в вызываемой карте.

`boolean containsKey(Object k)` - Возвращает true, если вызываемая карта содержит k как ключ. В противном случае, возвращает false.

`boolean containsValue(Object v)` - Возвращает true, если карта содержит v как значение. В противном случае, возвращает false.

`Set entrySet()` - Возвращает набор, содержащий записи на карте. Набор содержит объекты типа Map.Entry. Этот метод обеспечивает просмотр набора вызывающей карты.

`boolean equals(Object obj)` - Возвращает true, если obj является Map и содержит одинаковые записи. В противном случае, возвращает false.

`Object get(Object k)` - Возвращает значение, связанное с ключом k.

`int hashCode()` - Возвращает хэш-код для вызываемой карты.

`boolean isEmpty()` - Возвращает true, если вызываемая карта пустая. В противном случае, возвращает false.

`Set keySet()` - Возвращает набор, который содержит ключи в вызываемой карте. Этот метод предоставляет набор ключей на вызывающей карте.

`Object put(Object k, Object v)` - Вставляет запись в вызываемую карту, перезаписывая любое предыдущее значение, связанное с ключом. Ключ и значения соответствуют k и v. Возвращает ноль, если ключ ещё не существует. В противном случае возвращается предыдущее значение, связанное с ключом.

`void putAll(Map m)` - Вставляет все записи из m в эту карту.

`Object remove(Object k)` - Удаляет запись, чей ключ равен k.

`int size()` - Возвращает количество пар ключей/значений в карте.

`Collection values()` - Возвращает коллекцию значений в карте. Этот метод предоставляет просмотр значений в карте. - Возвращает true, если карта содержит v как значение. В противном случае, возвращает false.

[к оглавлению](#Collections-Lite)

## 28. Расскажите, какие классы реализовывают интерфейс Map?

**Map** — это структура данных, которая содержит набор пар “ключ-значение”. По своей структуре данных напоминает словарь, поэтому ее часто так и называют. В то же время, Map является интерфейсом, и в стандартном jdk содержит основные реализации: *Hashmap*, *LinkedHashMap*, *Hashtable*, *TreeMap*.'

Класс **HashMap** хранит данные в виде хеш-таблицы.

Класс **TreeMap** строится на базе красно-чёрного дерева. Элементы здесь упорядочены (в естественном или заданном при создании порядке) в каждый момент времени. При этом вставка и удаление более затратны, чем в случае с HashMap.

Класс **LinkedHashMap** расширяет возможности HashMap тем, что позволяет итерироваться по элементам в порядке их добавления. Здесь каждая пара-значение содержит ссылку на предыдущий и последующий элементы.

Класс **Hashtable** реализует интерфейс Map, которая хранит пары ключ-значения. Hashtable является синхронизированной и потокобезопасной коллекцией. Hashtable не допускается null-ключей и дублирующих ключей, а также null-значений.

[к оглавлению](#Collections-Lite)

## 29. Расскажите о методах map.keySet и map.entrySet? Что такое Entry?

`Set<K> keySet()`: возвращает набор всех ключей отображения

`Set<Map.Entry<K, V>> entrySet()`: возвращает набор элементов коллекции. Все элементы представляют объект Map.Entry

Обобщенный интерфейс **Map.Entry<K, V>** представляет объект с ключом типа **K** и значением типа **V** и определяет следующие методы:

+ `boolean equals(Object obj)`: возвращает true, если объект obj, представляющий интерфейс Map.Entry, идентичен текущему

+ `K getKey()`: возвращает ключ объекта отображения

+ `V getValue()`: возвращает значение объекта отображения

+ `V setValue(V v)`: устанавливает для текущего объекта значение v

+ `int hashCode()`: возвращает хеш-код данного объекта

[к оглавлению](#Collections-Lite)

## 30. Что будет если вызвать метод map.put несколько раз с одинаковым ключем?

По определению команда `put` заменяет предыдущее значение, связанное с данным ключом на карте (концептуально, как операция индексирования массива для примитивных типов).

Можно избежать перезаписи значения ключа, командой:

`putIfAbsent(K k, V v)`: помещает в коллекцию новый объект с ключом k и значением v, если в коллекции еще нет элемента с подобным ключом.

[к оглавлению](#Collections-Lite)

## 30. В чем разница между Iterator и Iterable?

Если какой-либо класс реализует **Iterable** интерфейс, он получает возможность перебирать объект этого класса, используя **Iterator**.

**Iterable** представляет коллекцию, которую можно обойти. Реализация **Iterable** Интерфейса позволяет объекту использовать цикл `for-each`. Он делает это, внутренне вызывая `iterator()` метод на объекте.

```java
List<String> persons = new ArrayList<>(Arrays.asList("A", "B", "C"));
 
for (String person: persons) {
    System.out.println(person);
}
```

**Iterator** — это интерфейс, который позволяет нам перебирать какой-то другой объект, который является какой-то коллекцией. Чтобы перебрать, мы можем использовать hasNext() и next() методы в цикле while.

```java
Iterator<String> countriesIterator = countries.iterator();
while(countriesIterator.hasNext()) {
    System.out.println(countriesIterator.next());
}
```

**Iterator** экземпляр хранит состояние итерации. Это означает, что он предоставляет служебные методы для получения текущего элемента, проверки существования следующего элемента и перехода к следующему элементу, если он присутствует. Другими словами, **Iterator** запоминает текущую позицию в коллекции и возвращает следующий по порядку элемент, если он присутствует. Iterable, с другой стороны, не поддерживает никакого такого состояния итерации.

Для **Iterable**, мы можем двигаться вперед только в прямом направлении, но, например ListIterator позволяет нам перемещаться вперед и назад по List.

Также, **Iterable** не предоставляет никакого метода для изменения своих элементов, и мы не можем изменить их с помощью цикла for-each. Но Iterator позволяет удаление элементов из базовой коллекции во время итерации с remove() метод.

[к оглавлению](#Collections-Lite)
